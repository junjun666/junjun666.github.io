<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-14T01:22:13.713Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端知识点梳理总结(一)</title>
    <link href="http://yoursite.com/2019/10/13/knowledge-sum/"/>
    <id>http://yoursite.com/2019/10/13/knowledge-sum/</id>
    <published>2019-10-13T03:10:48.000Z</published>
    <updated>2019-10-14T01:22:13.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一：js单例模式"><a href="#一：js单例模式" class="headerlink" title="一：js单例模式"></a>一：js单例模式</h3><p>何为单例模式：单例要求一个类有且只有一个实例<br>es5写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var Singleton = function(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.instance = null;</span><br><span class="line">&#125;</span><br><span class="line">Singleton.getInstance = function(name) &#123;</span><br><span class="line">    if(!this.instance) &#123; //这里的this指向Singleton这个类</span><br><span class="line">        this.instance = new Singleton(name);</span><br><span class="line">    &#125;</span><br><span class="line">    return this.instance;</span><br><span class="line">&#125;</span><br><span class="line">var a = Singleton.getInstance(&apos;sven1&apos;);//返回值为Singleton &#123;name: &quot;sven1&quot;, instance: null&#125;</span><br><span class="line">var b = Singleton.getInstance(&apos;sven2&apos;);//返回值为Singleton &#123;name: &quot;sven1&quot;, instance: null&#125;</span><br><span class="line">// 指向的是唯一实例化的对象</span><br><span class="line">console.log(a === b);//true</span><br></pre></td></tr></table></figure></p><p>es6写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.instance = null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 构造一个广为人知的接口，供用户对该类进行实例化</span><br><span class="line">    static getInstance(name) &#123;</span><br><span class="line">        if(!this.instance) &#123;</span><br><span class="line">            this.instance = new Singleton(name);</span><br><span class="line">        &#125;</span><br><span class="line">        return this.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二：js观察者模式"><a href="#二：js观察者模式" class="headerlink" title="二：js观察者模式"></a>二：js观察者模式</h3><p>Observer模式是行为模式之一，它的作用是当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态。</p><p>Observer模式提供给关联对象一种同步通信的手段，使某个对象与依赖它的其他对象之间保持状态同步。</p><p>包括我们平时接触的dom事件. 也是js和dom之间实现的一种观察者模式.<br>只要订阅了div的click事件. 当点击div的时候, function click就会被触发.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div.onclick = function click ()&#123;</span><br><span class="line">  alert (&quot;click&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 发布订阅模式(观察者模式)</span><br><span class="line"> * handles: 事件处理函数集合</span><br><span class="line"> * on: 订阅事件</span><br><span class="line"> * emit: 发布事件</span><br><span class="line"> * off: 删除事件</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">class PubSub &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.handles = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 订阅事件</span><br><span class="line">  on(eventType, handle) &#123;</span><br><span class="line">    if (!this.handles.hasOwnProperty(eventType)) &#123;</span><br><span class="line">      this.handles[eventType] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof handle == &apos;function&apos;) &#123;</span><br><span class="line">      this.handles[eventType].push(handle);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new Error(&apos;缺少回调函数&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 发布事件</span><br><span class="line">  emit(eventType, ...args) &#123;</span><br><span class="line">    if (this.handles.hasOwnProperty(eventType)) &#123;</span><br><span class="line">      this.handles[eventType].forEach((item, key, arr) =&gt; &#123;</span><br><span class="line">        item.apply(null, args);//这里的item是调用on方法时加入的函数，这里通过apply传递进去args参数进行执行。</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new Error(`&quot;$&#123;eventType&#125;&quot;事件未注册`);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 删除事件</span><br><span class="line">  off(eventType, handle) &#123;</span><br><span class="line">    if (!this.handles.hasOwnProperty(eventType)) &#123;</span><br><span class="line">      throw new Error(`&quot;$&#123;eventType&#125;&quot;事件未注册`);</span><br><span class="line">    &#125; else if (typeof handle != &apos;function&apos;) &#123;</span><br><span class="line">      throw new Error(&apos;缺少回调函数&apos;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.handles[eventType].forEach((item, key, arr) =&gt; &#123;</span><br><span class="line">        if (item == handle) &#123;</span><br><span class="line">          arr.splice(key, 1);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return this; // 实现链式操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 下面做一些骚操作</span><br><span class="line">let callback = function () &#123;</span><br><span class="line">  console.log(&apos;you are so nice&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let pubsub = new PubSub();</span><br><span class="line">pubsub.on(&apos;completed&apos;, (...args) =&gt; &#123;</span><br><span class="line">  console.log(args.join(&apos; &apos;));</span><br><span class="line">&#125;).on(&apos;completed&apos;, callback);</span><br><span class="line"></span><br><span class="line">pubsub.emit(&apos;completed&apos;, &apos;what&apos;, &apos;a&apos;, &apos;fucking day&apos;);</span><br><span class="line">pubsub.off(&apos;completed&apos;, callback);//把callback事件删除了</span><br><span class="line">pubsub.emit(&apos;completed&apos;, &apos;fucking&apos;, &apos;again&apos;);</span><br></pre></td></tr></table></figure><h3 id="三-强语言和弱语言"><a href="#三-强语言和弱语言" class="headerlink" title="三: 强语言和弱语言"></a>三: 强语言和弱语言</h3><p>强语言要求变量的使用要严格符合定义，所有变量都必须先定义后使用。所以，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了，无法再更改了。</p><p>(java、C++)(Python属于强类型的动态脚本语言)(强类型：不予许不同类型相加/动态：不使用显示数据声明类型，且确定一个变量的类型是第一次给他赋值的时候/脚本语言：一般也是解释性语言，运行代码只需要一个解释器，不需要编译)</p><p>弱语言是数据类型可以被忽略的语言， 一个变量可以赋值给不同数据类型的值。(php,js)</p><h3 id="四：进程和线程"><a href="#四：进程和线程" class="headerlink" title="四：进程和线程"></a>四：进程和线程</h3><p>说一下线程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多线程可以并行处理任务，线程不能单独存在，它是由进程来启动和管理的。</span><br><span class="line"></span><br><span class="line">那么进程是什么嘞</span><br></pre></td></tr></table></figure></p><p>一个进程是一个程序的运行实例。</p><p>总结：所以线程依附于进程，而进程中使用多线程并行处理能提升运算效率。</p><p>以下是进程和线程其四个特点：<br>1）进程中任意一线程执行出错，都会导致整个进程的崩溃。<br>2）线程之间共享进程中的数据。<br>3）当一个进程关闭之后，操作系统会回收进程所占用的内存。<br>4）进程之间的内容相互隔离。</p><p>那么之前单进程浏览器时代：浏览器所有的功能模块都是运行在同一个进程里，所以会出现以下几个问题：<br>1)不稳定<br>2)不流畅<br>3)不安全<br>那么对于现在多进程浏览器时代解决了上述问题，那么最新的Chrome进程架构包括：<br>一个浏览器主进程、一个GPU进程、一个网络进程、多个渲染进程和多个插件进程。<br>参考资料：<br><a href="https://www.jianshu.com/p/df130352d2ed" target="_blank" rel="noopener">js单例模式</a><br>[]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一：js单例模式&quot;&gt;&lt;a href=&quot;#一：js单例模式&quot; class=&quot;headerlink&quot; title=&quot;一：js单例模式&quot;&gt;&lt;/a&gt;一：js单例模式&lt;/h3&gt;&lt;p&gt;何为单例模式：单例要求一个类有且只有一个实例&lt;br&gt;es5写法&lt;br&gt;&lt;figure cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React中createElement 和 cloneElement 的区别</title>
    <link href="http://yoursite.com/2019/10/09/create-clone-element/"/>
    <id>http://yoursite.com/2019/10/09/create-clone-element/</id>
    <published>2019-10-09T06:03:56.000Z</published>
    <updated>2019-10-09T07:11:10.900Z</updated>
    
    <content type="html"><![CDATA[<h3 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement()"></a>React.createElement()</h3><p>JSX 语法就是用React.createElement()来构建 React 元素的。它接受三个参数：<br>1)第一个参数可以是一个标签名。如div、span，或者 React 组件。<br>2)第二个参数为传入的属性。<br>3)第三个以及之后的参数，皆作为组件的子组件。<br>其基本结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">    type,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>让我们看一下它实际的两种写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">写法一：</span><br><span class="line"></span><br><span class="line">var child1 = React.createElement(&apos;li&apos;, null, &apos;one&apos;);</span><br><span class="line">var child2 = React.createElement(&apos;li&apos;, null, &apos;two&apos;);</span><br><span class="line">var content = React.createElement(&apos;ul&apos;, &#123; className: &apos;teststyle&apos; &#125;, child1, child2); // 第三个参数可以分开也可以写成一个数组</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    content,</span><br><span class="line">    document.getElementById(&apos;example&apos;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">写法二：</span><br><span class="line"></span><br><span class="line">var child1 = React.createElement(&apos;li&apos;, null, &apos;one&apos;);</span><br><span class="line">var child2 = React.createElement(&apos;li&apos;, null, &apos;two&apos;);</span><br><span class="line">var content = React.createElement(&apos;ul&apos;, &#123; className: &apos;teststyle&apos; &#125;, [child1, child2]);</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    content,</span><br><span class="line">    document.getElementById(&apos;example&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>在我们应用JSX进行开发的时候，其实它最终会转化成React.createElement…去创建元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//JSX写法：</span><br><span class="line"></span><br><span class="line">class Hello extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;Hello, &#123; this.props.toWhat &#125;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Hello toWhat=‘world’&gt;,</span><br><span class="line">    document.getElementById(‘root’)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 转化为原生JS后的写法</span><br><span class="line"></span><br><span class="line">class Hello extends React.Component &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return React.createElement(‘div’,null, `Hello,$&#123;this.props.toWhat&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    React.createElement(Hello, &#123; toWhat: ‘world’ &#125;, null),</span><br><span class="line">    document.getElementById(‘root’)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="React-cloneElement"><a href="#React-cloneElement" class="headerlink" title="React.cloneElement()"></a>React.cloneElement()</h3><p>React.cloneElement()与React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。<br>其基本结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.cloneElement(</span><br><span class="line">  element,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>(重点记住定义)克隆并返回一个新的 ReactElement （内部子元素也会跟着克隆），新返回的元素会保留有旧元素的 props、ref、key，也会集成新的 props（只要在第二个参数中有定义）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var Li = React.createClass(&#123;</span><br><span class="line">    render: function() &#123;</span><br><span class="line">        return &lt;li&gt;&#123;this.props.i&#125;&lt;/li&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">var Ul = React.createClass(&#123;</span><br><span class="line">    deal : function(child, index)&#123;</span><br><span class="line">        //注意下面这行换成 createElement 会报错！因为child是ReactElement而不是ReactClass或字符串</span><br><span class="line">        return React.cloneElement(child, &#123;i:index&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: function() &#123;</span><br><span class="line">        return &lt;ul&gt;&#123;this.props.children.map(this.deal)&#125;&lt;/ul&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">React.render((</span><br><span class="line">    &lt;Ul&gt;</span><br><span class="line">        &lt;Li i=&quot;9&quot; /&gt;</span><br><span class="line">        &lt;Li i=&quot;8&quot; /&gt;</span><br><span class="line">        &lt;Li i=&quot;7&quot; /&gt;</span><br><span class="line">    &lt;/Ul&gt;</span><br><span class="line">), document.body);</span><br></pre></td></tr></table></figure></p><p>参考资料：<br><a href="https://blog.csdn.net/u013558749/article/details/80268449" target="_blank" rel="noopener">React.createElement的理解使用</a><br><a href="https://zhirongyuan.github.io/blog/2017/03/10/Blog-entry-two.html" target="_blank" rel="noopener">React 克隆组件 —– React.cloneElement</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;React-createElement&quot;&gt;&lt;a href=&quot;#React-createElement&quot; class=&quot;headerlink&quot; title=&quot;React.createElement()&quot;&gt;&lt;/a&gt;React.createElement()&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react性能优化之PureComponent(重点)</title>
    <link href="http://yoursite.com/2019/09/30/react-PureComponent/"/>
    <id>http://yoursite.com/2019/09/30/react-PureComponent/</id>
    <published>2019-09-30T02:21:30.000Z</published>
    <updated>2019-09-30T04:59:03.446Z</updated>
    
    <content type="html"><![CDATA[<p>react版本16.10.1（截止到2019年9月28日）<br>那么在这篇文章里我会介绍一下关于React15.3的一个新特性PureComponent.</p><h4 id="开篇简单讲解一下："><a href="#开篇简单讲解一下：" class="headerlink" title="开篇简单讲解一下："></a>开篇简单讲解一下：</h4><p>React15.3中新加了一个PureComponent类，取代之前的PureRenderMixin , PureComponent可以进行React性能优化，减少不必要的render渲染次数，使用时只要把继承类从Component换成PureComponent。</p><p>PureComponent的原理是继承了Component类，自动加载shouldComponentUpdate函数，当组件更新时，shouldComponentUpdate对props和state进行了一层浅比较，如果组件的props和state都没有发生改变，render方法就不会触发，省去Virtual DOM的生成和对比过程，达到提升性能的目的。</p><h4 id="那么在这里我们从头开始，先来讲解一下shouldComponentUpdate这个生命周期"><a href="#那么在这里我们从头开始，先来讲解一下shouldComponentUpdate这个生命周期" class="headerlink" title="那么在这里我们从头开始，先来讲解一下shouldComponentUpdate这个生命周期"></a>那么在这里我们从头开始，先来讲解一下shouldComponentUpdate这个生命周期</h4><p>在PureComponent之前，我们经常看到优化react性能最常见的手段之一就是在react的生命周期函数shouldComponentUpdate里判断props或state的数据是否发生变化，通过返回ture(更新)和false(不更新)来阻止不必要的render.<br>首先我们来看两端代码：<br>App.js文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;</span><br><span class="line">import ShouldComponentUpdateList from &apos;./ShouldComponentUpdateList&apos;</span><br><span class="line"></span><br><span class="line">// 容器组件</span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        data: []</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        // 定时任务，每隔一秒更新数据</span><br><span class="line">        setInterval(() =&gt; &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                data: [</span><br><span class="line">                    &#123; title: &apos;react line 1&apos; &#125;, </span><br><span class="line">                    &#123; title: &apos;react line 2&apos; &#125;, </span><br><span class="line">                ]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    this.state.data.map((item, index) =&gt; (</span><br><span class="line">                        &lt;ShouldComponentUpdateList key=&#123;index&#125; list=&#123;item&#125; /&gt;</span><br><span class="line">                    ))</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ShouldComponentUpdateList组件内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default class List extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        console.log(&apos;list render&apos;)</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;&#123;this.props.list.title&#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>命令行运行npm start，浏览器查看输出发现每一秒都会执行一次render方法，明明数据没有发生变化，但是react还是发生渲染，造成了不必要的渲染浪费。</p><h4 id="用shouldComponentUpdate改进的方法"><a href="#用shouldComponentUpdate改进的方法" class="headerlink" title="用shouldComponentUpdate改进的方法"></a>用shouldComponentUpdate改进的方法</h4><p>只需要在shouldComponentUpdate里加上判断，再次查看输出结果，定时任务的数据没有发生改变，不会再渲染render函数<br>ShouldComponentUpdateList组件内容更改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export default class List extends Component &#123;</span><br><span class="line">    // 在shouldComponentUpdate里判断props传递的数据没有发生变化，则不需要render</span><br><span class="line">    shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">        // 返回值为true则render，为false则不render.</span><br><span class="line">        if(nextProps.list.title === this.props.list.title) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        console.log(&apos;list render&apos;)</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;&#123;this.props.list.title&#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="PureComponent使用"><a href="#PureComponent使用" class="headerlink" title="PureComponent使用"></a>PureComponent使用</h4><p>除了使用shouldComponentUpdate来判断是否需要更新组件，还可以用PureComponent, PureComponent实际上自动加载shouldComponentUpdate函数，当组件更新时，shouldComponentUpdate对props和state进行了一层浅比较.<br>新建PureComponentList组件，用PureComponent代替Component：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; PureComponent &#125; from &apos;react&apos;</span><br><span class="line">export default class List extends PureComponent &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        console.log(&apos;list render&apos;)</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;&#123;this.props.list.title&#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>App.js组件传入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.state.data.map((item, index) =&gt; (</span><br><span class="line">    &lt;PureComponentList key=&#123;index&#125; list=&#123;item&#125;/&gt;</span><br><span class="line">))</span><br></pre></td></tr></table></figure></p><p>然后查看浏览器输出结果，惊奇地发生，PureComponent并没有阻止不必要render，这是为什么呢？因为前面我们说到PureComponent的shouldComponentUpdate只对props和state进行浅比较，也就是this.props = { list: { title: ‘react line1’ } }，nextProps = { list: { title: ‘react line1’ } }，作浅比较的话this.props当然不等于next.props.</p><h4 id="所以重点来了：如何才能真正的用好PureComponent这个组件呢"><a href="#所以重点来了：如何才能真正的用好PureComponent这个组件呢" class="headerlink" title="所以重点来了：如何才能真正的用好PureComponent这个组件呢"></a>所以重点来了：如何才能真正的用好PureComponent这个组件呢</h4><p>1)从源码角度来分析：对于对象的比较仅仅通过if (objA === objB) { return true; }来判断<br>而let a = { list: { title: ‘react line1’ } }，let b = { list: { title: ‘react line1’ } }, a === b值为false，那么会返回return true。那么会继续的渲染更新。所以这就很好的解释了上面PureComponent并没有阻止不必要render的原因。<br>2)由上面探究PureComponent源码我们知道，PureComponent的组件在props或者state的属性值是对象的情况下，并不能阻止不必要的渲染，是因为自动加载的shouldComponentUpdate里面做的只是浅比较，所以想要用PureComponent的特性，应该遵守原则：<br>(重点)确保数据类型是值类型<br>(重点)如果是引用类型，不应当有深层次的数据变化(解构)。</p><h4 id="那么下面我将会对代码进行一次更改"><a href="#那么下面我将会对代码进行一次更改" class="headerlink" title="那么下面我将会对代码进行一次更改"></a>那么下面我将会对代码进行一次更改</h4><p>App.js文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.state.data.map((item, index) =&gt; (</span><br><span class="line">    // &lt;PureComponentList key=&#123;index&#125; list=&#123;item&#125;/&gt;</span><br><span class="line">    &lt;PureComponentList key=&#123;index&#125; title=&#123;item.title&#125;/&gt;</span><br><span class="line">))</span><br></pre></td></tr></table></figure></p><p>这样的话就达到我们想要的效果咯~</p><h4 id="拓展：React-memo"><a href="#拓展：React-memo" class="headerlink" title="拓展：React.memo"></a>拓展：React.memo</h4><p>在使用PureComponent的时候，只能把react组件写成是class的形式，不能使用函数的形式；react v16.6.0之后，可以使用React.memo来实现函数式的组件，也有了PureComponent的功能。</p><p>List组件的PureComponent:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const ListComponent = React.momo(() =&gt; (</span><br><span class="line">    &lt;div&gt;&#123;this.props.data || &apos;loading&apos;&#125;&lt;/div&gt;</span><br><span class="line">))</span><br></pre></td></tr></table></figure></p><p>参考资料：<a href="https://segmentfault.com/a/1190000018641319" target="_blank" rel="noopener">React性能优化：PureComponent的使用原则</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;react版本16.10.1（截止到2019年9月28日）&lt;br&gt;那么在这篇文章里我会介绍一下关于React15.3的一个新特性PureComponent.&lt;/p&gt;
&lt;h4 id=&quot;开篇简单讲解一下：&quot;&gt;&lt;a href=&quot;#开篇简单讲解一下：&quot; class=&quot;headerl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react组件间通信(重点)</title>
    <link href="http://yoursite.com/2019/09/29/react-msg-transmit/"/>
    <id>http://yoursite.com/2019/09/29/react-msg-transmit/</id>
    <published>2019-09-29T08:20:42.000Z</published>
    <updated>2019-09-29T09:02:30.198Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1：没有任何嵌套关系的组件通信-毫无嵌套关系"><a href="#1：没有任何嵌套关系的组件通信-毫无嵌套关系" class="headerlink" title="1：没有任何嵌套关系的组件通信(毫无嵌套关系)"></a>1：没有任何嵌套关系的组件通信(毫无嵌套关系)</h4><p>利用自定义事件：自定义事件需要借用node.js的events模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装：npm install events --save</span><br><span class="line">引入：import &#123; EventEmitter &#125; from &quot;events&quot;;</span><br><span class="line">     export default new EventEmitter(); // 初始化实例并输出给其他组件使用</span><br></pre></td></tr></table></figure></p><p>具体的代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">export default class App extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                //这里定义了两个毫无关联的组件，Boo组件向Foo组件传值</span><br><span class="line">                &lt;Foo /&gt;</span><br><span class="line">                &lt;Boo /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class Foo extends Component&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            msg:null,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        // 声明一个自定义事件,接受到msg的参数进行渲染。</span><br><span class="line">        this.eventEmitter = emitter.on(&quot;callMe&quot;,(msg)=&gt;&#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                msg,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 组件销毁前移除事件监听</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        emitter.removeListener(this.eventEmitter);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123; this.state.msg &#125;</span><br><span class="line">                我是非嵌套 1 号</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class Boo extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        const cb = (msg) =&gt; &#123;</span><br><span class="line">            return () =&gt; &#123;</span><br><span class="line">                // 触发自定义事件。参一为事件名，后面为传递给事件的参数，可多个。</span><br><span class="line">                emitter.emit(&quot;callMe&quot;,&quot;Hello&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                我是非嵌套 2 号</span><br><span class="line">                &lt;button onClick = &#123; cb(&quot;blue&quot;) &#125;&gt;点击我&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-父组件向子组件传值"><a href="#2-父组件向子组件传值" class="headerlink" title="2:父组件向子组件传值"></a>2:父组件向子组件传值</h4><p>父组件通过props向子组件传递需要的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        //这边子组件通过this.props接受到值</span><br><span class="line">        const &#123; name &#125; = this.props;</span><br><span class="line">        return &lt;p&gt;hello, &#123; name &#125;&lt;/p&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Child name=&apos;Bob&apos; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3：子组件向父组件通信"><a href="#3：子组件向父组件通信" class="headerlink" title="3：子组件向父组件通信"></a>3：子组件向父组件通信</h4><p>通过回调函数的方式比较普遍<br>其原理为：父组件将一个函数作为props传递给子组件，子组件调用这个回调函数，将想要传递的信息，作为参数，传递给父组件。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Parent extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.handleClick = this.handleClick.bind(this);</span><br><span class="line">        this.state=&#123;</span><br><span class="line">            visible: false。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleClick()&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            visible: true,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;React.Fragment&gt;</span><br><span class="line">                &lt;div style=&#123;&#123;display: this.state.visible ? &apos;block&apos; : &apos;none&apos;&#125;&#125;&gt;</span><br><span class="line">                    我是被隐藏的文字</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;Child name=&apos;Bob&apos; handleClick=&#123;this.handleClick&#125; /&gt;</span><br><span class="line">            &lt;/React.Fragment&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        const &#123; handleClick &#125; = this.props;</span><br><span class="line">        //子组件拿到父组件的handleClick函数,并将它作为参数返回给父组件，父组件点击会触发对应的效果。</span><br><span class="line">        return (&lt;button onClick=&#123;handleClick&#125;&gt;点击显示隐藏的文字&lt;/button&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4：跨级组件通信"><a href="#4：跨级组件通信" class="headerlink" title="4：跨级组件通信"></a>4：跨级组件通信</h4><p>对于跨级组件，像爷孙这种传递方式，一般有两种方法：（1）向层层传递props。（2）利用context。<br>1)这里我比较推荐用this.props层层传递的方式，虽然弊端是对于组件结构较深，比较复杂，但一般情况下可以避免这种嵌套较深的结构。<br>2)Context就像全局变量一样，而全局变量正是导致应用走向混乱的罪魁祸首之一，给组件带来了外部依赖的副作用，因此，不推荐使用context。其比较好的应用场景是：真正意义上的全局信息且不会更改，如界面主题，用户信息。总体原则是：如果真的需要使用，建议写成高阶组件来实现。</p><p>参考资料：<a href="https://www.jianshu.com/p/032d929e1b9f" target="_blank" rel="noopener">React组件间通信</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1：没有任何嵌套关系的组件通信-毫无嵌套关系&quot;&gt;&lt;a href=&quot;#1：没有任何嵌套关系的组件通信-毫无嵌套关系&quot; class=&quot;headerlink&quot; title=&quot;1：没有任何嵌套关系的组件通信(毫无嵌套关系)&quot;&gt;&lt;/a&gt;1：没有任何嵌套关系的组件通信(毫无嵌
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>chrome开发者工具</title>
    <link href="http://yoursite.com/2019/09/27/chrome-panel/"/>
    <id>http://yoursite.com/2019/09/27/chrome-panel/</id>
    <published>2019-09-27T06:31:15.000Z</published>
    <updated>2019-09-27T07:09:37.403Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-chrome开发者工具之10大面板功能"><a href="#1-chrome开发者工具之10大面板功能" class="headerlink" title="1:chrome开发者工具之10大面板功能"></a>1:chrome开发者工具之10大面板功能</h4><p>1)Elements面板：可以查看dom结构，编辑css样式，用于测试页面布局和设计页面<br>2)Console面板：可以看成是Javascript Shell,能执行javascript脚本。通过console还能和页面中的javascript对象交互。<br>3)Sources面板: 1、查看Web应用加载的所有文件 2、编辑css和javasrcipt的文件内容 3、将打乱的css文件和javascript文件格式化 4、支持javasrcipt的调试功能 5、设置工作区，将更改的文件保存到本地文件夹中<br>4)NetWork面板：展示了页面中所有请求内容列表，能查看每项请求的请求行、请求头、请求体、时间线以及网络请求瀑布图等信息。<br>5）Performance面板：记录和查看Web应用声明周期内的各种事件，并用来在分析过程中一些影响性能的要点。<br>6）Memory面板：用来查看运行过程中的javascript占用堆内存情况，追踪是否存在内存泄漏的情况等。<br>7）Application面板：查看WEB应用的数据存储情况。PWA的基础数据：IndexedDB;Web SQL;本地和会话存储；Cookie;应用程序缓存；图像；字体和样式表等。<br>8）Security面板：显示当前页面一些基础的安全信息<br>9）Audits面板：会对当前网页进行网络利用情况，网页性能方面的诊断，并给出一些优化建议<br>10）Layers面板：展示一些渲染过程中的分层的基础信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-chrome开发者工具之10大面板功能&quot;&gt;&lt;a href=&quot;#1-chrome开发者工具之10大面板功能&quot; class=&quot;headerlink&quot; title=&quot;1:chrome开发者工具之10大面板功能&quot;&gt;&lt;/a&gt;1:chrome开发者工具之10大面板功能&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack插件之html-webpack-plugin</title>
    <link href="http://yoursite.com/2019/09/17/html-webpack-plugin/"/>
    <id>http://yoursite.com/2019/09/17/html-webpack-plugin/</id>
    <published>2019-09-17T05:47:15.000Z</published>
    <updated>2019-09-17T07:33:44.587Z</updated>
    
    <content type="html"><![CDATA[<p>这里只介绍开发时用法，基础知识详见笔记<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">var models = require(&apos;./models.json&apos;),//这里的models文件主要是关于一些json数据。</span><br><span class="line">    webpack = require(&apos;webpack&apos;),</span><br><span class="line">    HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;),</span><br><span class="line">    _ = require(&apos;lodash&apos;);</span><br><span class="line">var htmlPlugin = function (language) &#123;</span><br><span class="line">    return _.map(models, function(value,key) &#123;</span><br><span class="line">        return new HtmlWebpackPlugin(&#123;</span><br><span class="line">            title: value,</span><br><span class="line">            //生成模板地址</span><br><span class="line">            template: &apos;./src/pages/&apos;+key+&apos;/index.ejs&apos;,</span><br><span class="line">            filename: key+&apos;/index.html&apos;,</span><br><span class="line">            //chunks这个参数告诉插件要引用entry里面的哪几个入口</span><br><span class="line">            chunks: [&apos;mainfest&apos;, &apos;vendor&apos;, key],</span><br><span class="line">            //要把script插入到标签里</span><br><span class="line">            inject: &apos;body&apos;,</span><br><span class="line">            hash: true,</span><br><span class="line">            minify:&#123;    //压缩HTML文件（注意，虽然minify支持BooleanObject,但是不能直接这样写：minify: true , 这样会报错 ERROR in TypeError: Cannot use &apos;in&apos; operator to search for &apos;html5&apos; in true , 使用时候必须给定一个 &#123; &#125; 对象 ）</span><br><span class="line">                collapseWhitespace:true    //删除空白符与换行符</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;files&quot;: &#123;</span><br><span class="line">                &quot;css&quot;: [].concat([</span><br><span class="line">                    &quot;../static/font-awesome-4.5.0/css/font-awesome.min.css&quot;,</span><br><span class="line">                    //iuap</span><br><span class="line">                    &quot;../static/iuap-design-&quot;+iuapversion+&quot;/css/u.min.css&quot;,</span><br><span class="line">                    &quot;../static/iuap-design-&quot;+iuapversion+&quot;/css/grid.min.css&quot;,</span><br><span class="line">                    &quot;../static/css/base.css&quot;,</span><br><span class="line">                    &quot;../static/iuap-design-&quot;+iuapversion+&quot;/css/tree.css&quot;</span><br><span class="line">                ]),</span><br><span class="line">                &quot;js&quot;: [</span><br><span class="line">                    //jquery</span><br><span class="line">                    &quot;../static/js/jquery-2.1.1.js&quot;,</span><br><span class="line">                    &quot;../static/js/knockout/knockout-3.4.0.min.js&quot;,</span><br><span class="line">                    &quot;../static/iuap-design-&quot;+iuapversion+&quot;/js/u.js&quot;,</span><br><span class="line">                    &quot;../static/iuap-design-&quot;+iuapversion+&quot;/js/u-grid.js&quot;,</span><br><span class="line">                    &quot;../static/iuap-design-&quot;+iuapversion+&quot;/js/u-tree.js&quot;,</span><br><span class="line">                    &quot;../static/jquery.metismenu.js&quot;,</span><br><span class="line">                    &quot;../static/file/jquery.cookie.js&quot;,</span><br><span class="line">                    &quot;../static/file/ajaxfileupload.js&quot;,</span><br><span class="line">                    &quot;../static/file/interface.file.js&quot;,</span><br><span class="line">                    &quot;../static/file/interface.file.impl.js&quot;,</span><br><span class="line">                    &quot;../static/js/loading/jquery.mloading.js&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里只介绍开发时用法，基础知识详见笔记&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react-redux</title>
    <link href="http://yoursite.com/2019/08/29/react-redux/"/>
    <id>http://yoursite.com/2019/08/29/react-redux/</id>
    <published>2019-08-29T06:21:21.000Z</published>
    <updated>2019-08-29T06:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>1:两个工具函数redux的combineReducers和bindActionCreators的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import &#123;</span><br><span class="line">  createStore,</span><br><span class="line">  combineReducers,</span><br><span class="line">  bindActionCreators</span><br><span class="line">&#125; from &quot;redux&quot;;</span><br><span class="line"></span><br><span class="line">function run() &#123;</span><br><span class="line">  // Store initial state</span><br><span class="line">  const initialState = &#123; count: 0 &#125;;</span><br><span class="line"></span><br><span class="line">  // reducer的一个纯函数，有默认的初始值state</span><br><span class="line">  const counter = (state = initialState, action) =&gt; &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">      case &quot;PLUS_ONE&quot;:</span><br><span class="line">        return &#123; count: state.count + 1 &#125;;</span><br><span class="line">      case &quot;MINUS_ONE&quot;:</span><br><span class="line">        return &#123; count: state.count - 1 &#125;;</span><br><span class="line">      case &quot;CUSTOM_COUNT&quot;:</span><br><span class="line">        return &#123;</span><br><span class="line">          count: state.count + action.payload.count</span><br><span class="line">        &#125;;</span><br><span class="line">      default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return state;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const todos = (state = &#123;&#125;) =&gt; state;</span><br><span class="line"></span><br><span class="line">  // Create store,combineReducers把多个reducer整合成一个新的reducer</span><br><span class="line">  const store = createStore(</span><br><span class="line">    combineReducers(&#123;</span><br><span class="line">      todos,</span><br><span class="line">      counter</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  // Action creator</span><br><span class="line">  function plusOne() &#123;</span><br><span class="line">    // action</span><br><span class="line">    return &#123; type: &quot;PLUS_ONE&quot; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function minusOne() &#123;</span><br><span class="line">    return &#123; type: &quot;MINUS_ONE&quot; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function customCount(count) &#123;</span><br><span class="line">    return &#123; type: &quot;CUSTOM_COUNT&quot;, payload: &#123; count &#125; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  plusOne = bindActionCreators(plusOne, store.dispatch);//第一个参数是store.dispatch的plusOne方法，第二个参数传store.dispatch即可，这样可以直接调用plusOne()方法了。</span><br><span class="line"></span><br><span class="line">  store.subscribe(() =&gt; console.log(store.getState()));//监听store的值的变化</span><br><span class="line">  // store.dispatch(plusOne());</span><br><span class="line">  plusOne();</span><br><span class="line">  store.dispatch(minusOne());</span><br><span class="line">  store.dispatch(customCount(5));</span><br><span class="line">&#125;</span><br><span class="line">export default () =&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button onClick=&#123;run&#125;&gt;Run&lt;/button&gt;</span><br><span class="line">    &lt;p&gt;* 请打开控制台查看运行结果&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>2:在react中用redux<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import &#123; bindActionCreators, createStore &#125; from &quot;redux&quot;;</span><br><span class="line">import &#123; Provider, connect &#125; from &quot;react-redux&quot;;</span><br><span class="line"></span><br><span class="line">// Store initial state</span><br><span class="line">const initialState = &#123; count: 0 &#125;;</span><br><span class="line"></span><br><span class="line">// reducer</span><br><span class="line">const counter = (state = initialState, action) =&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &quot;PLUS_ONE&quot;:</span><br><span class="line">      return &#123; count: state.count + 1 &#125;;</span><br><span class="line">    case &quot;MINUS_ONE&quot;:</span><br><span class="line">      return &#123; count: state.count - 1 &#125;;</span><br><span class="line">    case &quot;CUSTOM_COUNT&quot;:</span><br><span class="line">      return &#123; count: state.count + action.payload.count &#125;;</span><br><span class="line">    default:</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  return state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Create store</span><br><span class="line">const store = createStore(counter);</span><br><span class="line"></span><br><span class="line">// Action creator</span><br><span class="line">function plusOne() &#123;</span><br><span class="line">  // action</span><br><span class="line">  return &#123; type: &quot;PLUS_ONE&quot; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function minusOne() &#123;</span><br><span class="line">  return &#123; type: &quot;MINUS_ONE&quot; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export class Counter extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; count, plusOne, minusOne &#125; = this.props;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;counter&quot;&gt;</span><br><span class="line">        &lt;button onClick=&#123;minusOne&#125;&gt;-&lt;/button&gt;</span><br><span class="line">        &lt;span style=&#123;&#123; display: &quot;inline-block&quot;, margin: &quot;0 10px&quot; &#125;&#125;&gt;</span><br><span class="line">          &#123;count&#125;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;button onClick=&#123;plusOne&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapStateToProps(state) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    count: state.count</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapDispatchToProps(dispatch) &#123;</span><br><span class="line">  return bindActionCreators(&#123; plusOne, minusOne &#125;, dispatch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const ConnectedCounter = connect(mapStateToProps, mapDispatchToProps)(Counter);</span><br><span class="line"></span><br><span class="line">export default class CounterSample extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;ConnectedCounter /&gt;</span><br><span class="line">      &lt;/Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1:两个工具函数redux的combineReducers和bindActionCreators的用法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>优秀博文合集</title>
    <link href="http://yoursite.com/2019/08/23/goodblog/"/>
    <id>http://yoursite.com/2019/08/23/goodblog/</id>
    <published>2019-08-23T12:17:35.000Z</published>
    <updated>2019-10-12T07:44:58.569Z</updated>
    
    <content type="html"><![CDATA[<p>1:Symbol用法<br>参考资料：<a href="https://blog.csdn.net/tyro_java/article/details/79667169" target="_blank" rel="noopener">ES6知识点整理Symbol的应用</a><br>参考资料：<a href="https://www.jianshu.com/p/41b13b624854" target="_blank" rel="noopener">Symbol基础知识</a></p><p>2:优秀博文地址<br><a href="https://www.cnblogs.com/Leophen" target="_blank" rel="noopener">https://www.cnblogs.com/Leophen</a><br><a href="https://www.cnblogs.com/Renyi-Fan/p/9267997.html" target="_blank" rel="noopener">https://www.cnblogs.com/Renyi-Fan/p/9267997.html</a></p><p>3：css3新单位vw、vh、vmin、vmax的使用详解<br>这里对vw vh用法做了详细的介绍。<br>1)首先通过vw和vh实现了蒙层。<br><a href="https://blog.csdn.net/ZNYSYS520/article/details/76053961" target="_blank" rel="noopener">https://blog.csdn.net/ZNYSYS520/article/details/76053961</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1:Symbol用法&lt;br&gt;参考资料：&lt;a href=&quot;https://blog.csdn.net/tyro_java/article/details/79667169&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ES6知识点整理Symbol的应用&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端性能优化总结</title>
    <link href="http://yoursite.com/2019/08/17/performance-optimizing/"/>
    <id>http://yoursite.com/2019/08/17/performance-optimizing/</id>
    <published>2019-08-17T03:32:34.000Z</published>
    <updated>2019-08-17T07:20:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本文会从三大部分来总结前端性能优化方面"><a href="#本文会从三大部分来总结前端性能优化方面" class="headerlink" title="本文会从三大部分来总结前端性能优化方面"></a>本文会从三大部分来总结前端性能优化方面</h3><p>一：数据方面</p><p>数据，也可以说是前端优化方面比较重要的一块内容。页面与用户的交互响应，往往伴随着数据交互，处理，以及ajax的异步请求等内容。所以，我们也可以来聊聊这一块的知识。首先是对于图片数据的处理：</p><p>1 图片加载处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">图片预加载</span><br><span class="line">图片懒加载</span><br><span class="line">首屏加载时进度条的显示</span><br></pre></td></tr></table></figure></p><p>1)图片预加载」，预加载的寓意就是提前加载内容。而图片的预加载往往会被用在图片资源比较大，即时加载时会导致很长的等待过程时，才会被使用的。常见场景：图片漫画展示时。往往会预加载一张到两张的图片。<br>2)「图片懒加载」，懒加载或许你是第一次听说，但是，这种方式在开发中会被经常使用。首先，我们需要明白一个道理：往往只有看到的资源是必须的，其他资源是可以随着用户的滚动，随即显示的。所以，特别是对于图片资源特别多的网站来说，做好图片的懒加载是可以大大提升网页的载入速度的。</p><h4 id="详细可见本博客的懒加载和预加载代码示例部分-skr"><a href="#详细可见本博客的懒加载和预加载代码示例部分-skr" class="headerlink" title="详细可见本博客的懒加载和预加载代码示例部分 skr~"></a>详细可见本博客的懒加载和预加载代码示例部分 skr~</h4><p>3)「首屏进度条的显示」：往往对于首屏优化后的数据量并不满意的话，同时也不能进一步缩短首屏包的长度了，就可以使用进度条的方式，来提醒用户进行等待。</p><p>2 异步请求的优化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用正常的json数据格式进行交互</span><br><span class="line">部分常用数据的缓存</span><br><span class="line">数据埋点和统计</span><br></pre></td></tr></table></figure></p><p>1)「JSON交互」，JSON的数据格式轻巧，结构简单，往往可以大大优化前后端的数据通信。<br>2)「常用数据的缓存」，可以将一些用户的基本信息等常用的信息做一个缓存，这样可以保证ajax请求的减少。同时，HTML5新增的storage的内容，也不用怕cookie暴露，引起的信息泄漏问题。<br>3)「数据埋点和统计」，对于资深的程序员来说，比较了解。而且目前的大部分公司也会做这方面的处理。有心的小伙伴可以自行查阅。</p><p>3 javascript多线程处理方式</p><p>最后，还有就是大量数据的运算。对于javascript语言来说，本身的单线程就限制了它并不能计算大量的数据，往往会造成页面的卡顿。而可能业务中有些复杂的UI需要去运行大量的运算，所以，webWorker的使用是至关重要的。</p><p>二：网络方面</p><p>web应用，总是会有一部分的时间浪费在网络连接和资源下载方面。往往建立一次网络连接是需要时间成本的。而且浏览器同一时间所发送的网络请求数是有限的。</p><p>1 减少http请求</p><p>在YUI35规则中也有提到，主要是优化js、css和图片资源三个方面，因为html是没有办法避免的。因此，我们可以做一下的几项操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">合并js文件</span><br><span class="line">合并css文件</span><br><span class="line">雪碧图的使用(css sprite)</span><br><span class="line">使用base64表示简单的图片</span><br></pre></td></tr></table></figure></p><p>上述四个方法，前面两者我们可以使用webpack之类的打包工具进行打包；雪碧图的话，也有专门的制作工具；图片的编码是使用base64的，所以，对于一些简单的图片，例如空白图等，可以使用base64直接写入html中。</p><p>2 减小资源体积<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip压缩</span><br><span class="line">js混淆</span><br><span class="line">css压缩</span><br><span class="line">图片压缩</span><br></pre></td></tr></table></figure></p><p>1）gzip压缩主要是针对html文件来说的，它可以将html中重复的部分进行一个打包，多次复用的过程。<br>2）js的混淆可以有简单的压缩(将空白字符删除)、丑化(丑化的方法，就是将一些变量缩小)、或者可以使用php对js进行混淆加密。<br>3）css压缩，就是进行简单的压缩。<br>4）图片的压缩，主要也是减小体积，在不影响观感的前提下，尽量压缩图片，使用png等图片格式，减少矢量图、高清图等的使用。这样子的做法不仅可以加快网页显示，也能减少流量的损耗。</p><p>3 缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DNS缓存</span><br><span class="line">CDN部署与缓存</span><br><span class="line">http缓存</span><br></pre></td></tr></table></figure></p><p>由于浏览器会在DNS解析步骤中消耗一定的时间，所以，对于一些高访问量网站来说，做好DNS的缓存工作，就会一定程度上提升网站效率。CDN缓存，CDN作为静态资源文件的分发网络，本身就已经提升了，网站静态资源的获取速度，加快网站的加载速度，同时也给静态资源做好缓存工作，有效的利用已缓存的静态资源，加快获取速度。http缓存，也是给资源设定缓存时间，防止在有效的缓存时间内对资源进行重复的下载，从而提升整体网页的加载速度。</p><p>4 移动端优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用长cache，减少重定向</span><br><span class="line">首屏优化，保证首屏加载数据小于14kb</span><br><span class="line">不滥用web字体</span><br></pre></td></tr></table></figure></p><p>「使用长cache」，可以使得移动端的部分资源设定长期缓存，这样可以保证资源不用向服务器发送请求，来比较资源是否更新，从而避免304的情况。304重定向，在PC端或许并不会影响网页的加载速度，但是，在移动端网络不稳定的前提下，多一次请求，就多了一部分加载时间。「首屏优化」，对于移动端来说是至关重要的。2s时间是用户的最佳体验，一旦超出这个时间，将会导致用户的流失。所以，针对移动端的网络情况，不可能在这么短时间内加载完成所有的网页资源，所以我们必须保证首屏中的内容被优先显示出来，而且基于TCP的慢启动和拥塞控制，第一个14kb的数据是非常重要的，所以需要保证首部加载数据能够小于14kb。「不滥用web字体」，web字体的好处就是，可以代替某些图片资源，但是，在移动端过多的web字体的使用，会导致页面资源加载的繁重，所以，慎用web字体</p><p>三 渲染和DOM操作方面</p><p>1 优化网页渲染：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">css的文件放在头部，js文件放在尾部或者异步</span><br><span class="line">尽量避免內联样式</span><br></pre></td></tr></table></figure><p>1)css文件放在「头部加载」，可以保证解析DOM的同时，解析css文件。因为，CSS（外链或内联）会阻塞整个DOM的渲染，然而DOM解析会正常进行，所以将css文件放在头部进行解析，可以加快网页的构建速度。假设将其放在尾部，那时DOM树几乎构建，这时就得等到CSSOM树构建完成，才能够继续下面的步骤。<br>2)「js放在尾部」：js文件不同，将js文件放在尾部或者异步加载的原因是JS（外链或内联）会阻塞后续DOM的解析，后续DOM的渲染也将被阻塞，而且一旦js中遇到DOM元素的操作，很可能会影响。<br>3)「避免使用内联样式」，可以有效的减少html的体积，一般考虑内联样式的时候，往往是样式本身体积比较小，往往加载网络资源的时间会大于它的时候。</p><p>2 DOM操作优化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">避免在document上直接进行频繁的DOM操作</span><br><span class="line">使用classname代替大量的内联样式修改</span><br><span class="line">对于复杂的UI元素，设置position为absolute或fixed</span><br><span class="line">尽量使用css动画</span><br><span class="line">使用requestAnimationFrame代替setInterval操作</span><br><span class="line">适当使用canvas</span><br><span class="line">尽量减少css表达式的使用</span><br><span class="line">使用事件代理</span><br></pre></td></tr></table></figure></p><p>前面三个操作，其实都是希望『减少回流和重绘』。其实，进行一次DOM操作的代价是非常之大的，以前可以通过网页操作是否卡顿来进行判断，但是，现代浏览器的进步已经大大减少了这方面的影响。但是，我们还是需要清楚，如何去减少回流和重绘的问题。因为这里不想细说这方面的知识，想要了解的话，可以看这篇文章——回流与重绘：CSS性能让JavaScript变慢？。这可是张鑫旭大大的一篇文章呦(^.^)。「尽量使用css动画」，是因为本身css动画比较简单，而且相较于js的复杂动画，浏览器本身对其进行了优化，使用上面不会出现卡顿等问题。「使用requestAnimationFrame代替setInterval操作」，相信大家都有所耳闻，setInterval定时器会有一定的延时，对于变动性高的动画来说，会出现卡顿现象。而requestAnimationFrame正好解决的整个问题。「适当使用canvas」，不得不说canvas是前端的一个进步，出现了它之后，前端界面的复杂性也随之提升了。一些难以完成的动画，都可以使用canvas进行辅助完成。但是，canvas使用频繁的话，会加重浏览器渲染的压力，同时导致性能的下降。所以，适当时候使用canvas是一个不错的建议。「尽量减少css表达式的使用」，这个在YUI规则中也被提到过，往往css的表达式在设计之初都是美好的，但在使用过程中，由于其频繁触发的特性，会拖累网页的性能，出现卡顿。因此在使用过程中尽量减少css表达式的使用，可以改换成js进行操作。「使用事件代理」：往往对于具备冒泡性质的事件来说，使用事件代理不失为一种好的方法。举个例子：一段列表都需要设定点击事件，这时如果你给列表中的每一项设定监听，往往会导致整体的性能下降，但是如果你给整个列表设置一个事件，然后通过点击定位目标来触发相应的操作，往往性能就会得到改善。</p><p>3 操作细节注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">避免图片或者frame使用空src</span><br><span class="line">在css属性为0时，去掉单位</span><br><span class="line">禁止图像缩放</span><br><span class="line">正确的css前缀的使用</span><br><span class="line">移除空的css规则</span><br><span class="line">对于css中可继承的属性，如font-size，尽量使用继承，少一点设置</span><br><span class="line">缩短css选择器，多使用伪元素等帮助定位</span><br></pre></td></tr></table></figure></p><p>4 移动端优化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">长列表滚动优化</span><br><span class="line">函数防抖和函数节流</span><br><span class="line">使用touchstart、touchend代替click</span><br><span class="line">HTML的viewport设置</span><br><span class="line">开启GPU渲染加速</span><br></pre></td></tr></table></figure></p><p>1)长列表滚动问题，是移动端需要面对的，IOS尽量使用局部滚动，android尽量使用全局滚动。同时，需要给body添加上-webkit-overflow-scrolling: touch来优化移动段的滚动。如果有兴趣的同学，可以去了解一下ios和android滚动操作上的区别以及优化。<br>2)「防抖和节流」，设计到滚动等会被频繁触发的DOM事件，需要做好防抖和节流的工作。它们都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。<br>3)「touchstart、touchend代替click」，也是移动端比较常用的操作。click在移动端会有300ms延时，这应该是一个常识呗。(不知道的小伙伴该收藏一下呦)。这种方法会影响用户的体验。所以做优化时，最简单的方法就是使用touchstart或者touchend代替click。因为它们事件执行顺序是touchstart-&gt;touchmove-&gt;touchend-&gt;click。或者，使用fastclick或者zepto的tap事件代替click事件。<br>4)「HTML的viewport设置」，可以防止页面的缩放，来优化性能。<br>5)「开启GPU渲染加速」，小伙伴们一定听过CPU吧，但是这里的GPU不能和CPU混为一谈呦。GPU的全名是Graphics Processing Unit，是一种硬件加速方式。一般的css渲染，浏览器的渲染引擎都不会使用到它。但是，在3D渲染时，计算量较大，繁重，浏览器会开启显卡的硬件加速来帮助完成这些操作。所以，我们这里可以使用css中的translateZ设定，来欺骗浏览器，让其帮忙开启GPU加速，加快渲染进程。</p><p>参考资料：<a href="https://www.jianshu.com/p/fe32ef31deed" target="_blank" rel="noopener">前端性能优化常用总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;本文会从三大部分来总结前端性能优化方面&quot;&gt;&lt;a href=&quot;#本文会从三大部分来总结前端性能优化方面&quot; class=&quot;headerlink&quot; title=&quot;本文会从三大部分来总结前端性能优化方面&quot;&gt;&lt;/a&gt;本文会从三大部分来总结前端性能优化方面&lt;/h3&gt;&lt;p&gt;一：
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>懒加载和预加载代码示例</title>
    <link href="http://yoursite.com/2019/08/14/preloading/"/>
    <id>http://yoursite.com/2019/08/14/preloading/</id>
    <published>2019-08-14T09:46:58.000Z</published>
    <updated>2019-08-17T03:48:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>一：懒加载：将图片src赋值为一张默认图片，当用户滚动滚动条到可视区域图片时候，再去加载真正的图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Lazyload 2&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    img &#123;</span><br><span class="line">        display: block;</span><br><span class="line">        margin-bottom: 50px;</span><br><span class="line">        height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/1.png&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/2.png&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/3.png&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/4.png&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/5.png&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/6.png&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/7.png&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/8.png&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/9.png&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/10.png&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/11.png&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/12.png&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line"></span><br><span class="line">    function throttle(fn, delay, atleast) &#123;//函数绑定在 scroll 事件上，当页面滚动时，避免函数被高频触发，</span><br><span class="line">        var timeout = null,//进行去抖处理</span><br><span class="line">        startTime = new Date();</span><br><span class="line">        return function() &#123;</span><br><span class="line">            var curTime = new Date();</span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">            if(curTime - startTime &gt;= atleast) &#123;</span><br><span class="line">                fn();</span><br><span class="line">                startTime = curTime;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                timeout = setTimeout(fn, delay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function lazyload() &#123;</span><br><span class="line">        var images = document.getElementsByTagName(&apos;img&apos;);</span><br><span class="line">        var len    = images.length;</span><br><span class="line">        var n      = 0;      //存储图片加载到的位置，避免每次都从第一张图片开始遍历        </span><br><span class="line">        return function() &#123;</span><br><span class="line">            var seeHeight = document.documentElement.clientHeight;</span><br><span class="line">            var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;</span><br><span class="line">            for(var i = n; i &lt; len; i++) &#123;</span><br><span class="line">                if(images[i].offsetTop &lt; seeHeight + scrollTop) &#123;</span><br><span class="line">                    if(images[i].getAttribute(&apos;src&apos;) === &apos;images/loading.gif&apos;) &#123;</span><br><span class="line">                        images[i].src = images[i].getAttribute(&apos;data-src&apos;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    n = n + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var loadImages = lazyload();</span><br><span class="line">    loadImages();          //初始化首页的页面图片</span><br><span class="line">    window.addEventListener(&apos;scroll&apos;, throttle(loadImages, 500, 1000), false);</span><br><span class="line">　　 //函数节流（throttle）与函数去抖（debounce）处理,</span><br><span class="line">    //500ms 的延迟，和 1000ms 的间隔，当超过 1000ms 未触发该函数，则立即执行该函数，不然则延迟 500ms 执行该函数</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>二：预加载：图片预加载即提前加载图片，可保证图片快速、无缝地发布，用户需要查看时可直接从本地缓存中渲染，适用于图片占据很大比例的网站。</p><p>方法一:JS new image对象，设置src加载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function preloader() &#123;</span><br><span class="line">    if (document.images) &#123;</span><br><span class="line">        var img1 = new Image();</span><br><span class="line">        var img2 = new Image();</span><br><span class="line">        var img3 = new Image();</span><br><span class="line">        img1.src = &quot;;;</span><br><span class="line">        img2.src = &quot;;;</span><br><span class="line">        img3.src = &quot;;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function addLoadEvent(func) &#123;</span><br><span class="line">    var oldonload = window.onload;</span><br><span class="line">    if (typeof window.onload != &apos;function&apos;) &#123;</span><br><span class="line">        window.onload = func;</span><br><span class="line">    &#125; else &#123;//onload中未挂载函数才执行该JS</span><br><span class="line">        window.onload = function() &#123;</span><br><span class="line">            if (oldonload) &#123;</span><br><span class="line">                oldonload();</span><br><span class="line">            &#125;</span><br><span class="line">            func();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">addLoadEvent(preloader);</span><br><span class="line">div.appendChild(img1);//插入到DOM</span><br></pre></td></tr></table></figure></p><p>方法二：Ajax预加载,new Image()对象设置src<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function() &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        // XHR to request a JS and a CSS</span><br><span class="line">        var xhr = new XMLHttpRequest();</span><br><span class="line">        xhr.open(&apos;GET&apos;, url;);</span><br><span class="line">        xhr.send();</span><br><span class="line">        xhr = new XMLHttpRequest();</span><br><span class="line">        xhr.open(&apos;GET&apos;, url;);</span><br><span class="line">        xhr.send();</span><br><span class="line">        // preload image</span><br><span class="line">        new Image().src = &quot;;;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>参考资料：<a href="https://www.cnblogs.com/rlann/p/7296660.html" target="_blank" rel="noopener">图片预加载和懒加载的实现方法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一：懒加载：将图片src赋值为一张默认图片，当用户滚动滚动条到可视区域图片时候，再去加载真正的图片&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域问题的解决方案</title>
    <link href="http://yoursite.com/2019/08/13/cross-domain/"/>
    <id>http://yoursite.com/2019/08/13/cross-domain/</id>
    <published>2019-08-13T08:41:29.000Z</published>
    <updated>2019-10-06T04:51:03.461Z</updated>
    
    <content type="html"><![CDATA[<p>方法一：Jsonp 需要目标服务器配合一个callback函数</p><p>它的基本思想是:网页通过添加一个script元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 </p><p>1)首先，网页动态插入script元素，由它向跨源网址发出请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Js 客户端 方法一</span><br><span class="line">&lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot; /&gt;  </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    function jsonpCallback(result) &#123;  </span><br><span class="line">        //alert(result);  </span><br><span class="line">        for(var i in result) &#123;  </span><br><span class="line">            alert(i+&quot;:&quot;+result[i]);//循环输出a:1,b:2,etc.  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    var JSONP=document.createElement(&quot;script&quot;);  </span><br><span class="line">    JSONP.type=&quot;text/javascript&quot;;  </span><br><span class="line">    JSONP.src=&quot;http://crossdomain.com/services.php?callback=jsonpCallback&quot;;  </span><br><span class="line">    document.getElementsByTagName(&quot;head&quot;)[0].appendChild(JSONP);  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Js 客户端 方案二</span><br><span class="line">&lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot; /&gt;  </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    function jsonpCallback(result) &#123;  </span><br><span class="line">        alert(result.a);  </span><br><span class="line">        alert(result.b);  </span><br><span class="line">        alert(result.c);  </span><br><span class="line">        for(var i in result) &#123;  </span><br><span class="line">            alert(i+&quot;:&quot;+result[i]);//循环输出a:1,b:2,etc.  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://crossdomain.com/services.php?callback=jsonpCallback&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>2)服务端接收到请求后，返回JSON数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">//服务端返回JSON数据  </span><br><span class="line">$arr=array(&apos;a&apos;=&gt;1,&apos;b&apos;=&gt;2,&apos;c&apos;=&gt;3,&apos;d&apos;=&gt;4,&apos;e&apos;=&gt;5);  </span><br><span class="line">$result=json_encode($arr);  </span><br><span class="line">//echo $_GET[&apos;callback&apos;].&apos;(&quot;Hello,World!&quot;)&apos;;  </span><br><span class="line">//echo $_GET[&apos;callback&apos;].&quot;($result)&quot;;  </span><br><span class="line">//动态执行回调函数  </span><br><span class="line">$callback=$_GET[&apos;callback&apos;];  </span><br><span class="line">echo $callback.&quot;($result)&quot;;</span><br></pre></td></tr></table></figure></p><p>方法二：document.domain</p><p>对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。 具体的做法是可以在<a href="http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上" target="_blank" rel="noopener">http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上</a> document.domain = “a.com”；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以 “交互”了。当然这种办法只能解决主域相同而二级域名不同的情况</p><p><a href="http://www.a.com上的a.html" target="_blank" rel="noopener">www.a.com上的a.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">document.domain = &apos;a.com&apos;;</span><br><span class="line">var ifr = document.createElement(&apos;iframe&apos;);</span><br><span class="line">ifr.src = &apos;http://script.a.com/b.html&apos;;</span><br><span class="line">ifr.style.display = &apos;none&apos;;</span><br><span class="line">document.body.appendChild(ifr);</span><br><span class="line">ifr.onload = function()&#123;</span><br><span class="line">  var doc = ifr.contentDocument || ifr.contentWindow.document;</span><br><span class="line">  // 在这里操纵b.html</span><br><span class="line">  alert(doc.getElementsByTagName(&quot;h1&quot;)[0].childNodes[0].nodeValue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>script.a.com上的b.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.domain = &apos;a.com&apos;;</span><br></pre></td></tr></table></figure></p><p>方法三：window.name</p><p>window 对象的name属性是一个很特别的属性，当在 frame 中加载新页面时，name 的属性值依旧保持不变。那么我们可以在页面 A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，此时 name 属性值可被获取到，以访问 Web 服务发送的信息。但 name 属性仅对相同域名的 frame 可访问。这意味着为了访问 name 属性，当远程 Web 服务页面被加载后，必须导航 frame 回到原始域。即页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。一旦 name 属性获得，销毁 frame 。这个方式非常适合单向的数据请求，而且协议简单、安全。</p><p>页面B(<a href="http://www.jesse.com/data.html)代码如下：" target="_blank" rel="noopener">www.jesse.com/data.html)代码如下：</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">window.name = &apos;I was there!&apos;;</span><br><span class="line">// 这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右</span><br><span class="line">// 数据格式可以自定义，如json、字符串</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>页面A(<a href="http://www.jack.com/index.html)代码如下" target="_blank" rel="noopener">www.jack.com/index.html)代码如下</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var state = 0,</span><br><span class="line">  iframe = document.createElement(&apos;iframe&apos;),</span><br><span class="line">  loadfn = function() &#123;</span><br><span class="line">    if (state === 1) &#123;</span><br><span class="line">      var data = iframe.contentWindow.name; // 读取数据</span><br><span class="line">      console.log(data); //弹出&apos;I wasthere!&apos;</span><br><span class="line">      (function()&#123;</span><br><span class="line">        //获取数据以后销毁这个iframe。</span><br><span class="line">        iframe.contentWindow.document.write(&apos;&apos;);</span><br><span class="line">        iframe.contentWindow.close();</span><br><span class="line">        document.body.removeChild(iframe);</span><br><span class="line">      &#125;)();</span><br><span class="line">    &#125; else if (state === 0) &#123;</span><br><span class="line">      state = 1;</span><br><span class="line">      // 设置的代理页面使其回原始域</span><br><span class="line">      iframe.contentWindow.location = &quot;http://www.jack.com/proxy.html&quot;; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">iframe.src = &apos;http://www.jesse.com/data.html&apos;;</span><br><span class="line">if (iframe.attachEvent) &#123;</span><br><span class="line">  iframe.attachEvent(&apos;onload&apos;, loadfn);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  iframe.onload = loadfn;</span><br><span class="line">&#125;</span><br><span class="line">document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>方法四：window.postMesage</p><p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。</p><p>pageA(<a href="http://www.jack.com/index.html)代码如下：" target="_blank" rel="noopener">www.jack.com/index.html)代码如下：</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;proxy&quot; src=&quot;http://www.jesse.com/index.html&quot; onload=&quot;postMsg()&quot; style=&quot;display: none&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  msg: &apos;hello world&apos;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function postMsg() &#123;</span><br><span class="line">  var iframe = document.getElementById(&apos;proxy&apos;);</span><br><span class="line">  var win = iframe.contentWindow;</span><br><span class="line">  win.postMessage(obj, &apos;http://www.jesse.com&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>pageB(<a href="http://www.jesse.com/data.php)代码如下" target="_blank" rel="noopener">www.jesse.com/data.php)代码如下</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">window.onmessage = function(e) &#123;</span><br><span class="line">  console.log(e.data.msg + &quot; from &quot; + e.origin);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>方法五：跨域资源共享（CORS）</p><p>原理:CORS需要浏览器和服务器同时支持，才可以实现跨域请求，目前几乎所有浏览器都支持CORS，IE则不能低于IE10。CORS的整个过程都由浏览器自动完成，前端无需做任何设置，跟平时发送ajax请求并无差异。所以，实现CORS的关键在于服务器，只要服务器实现CORS接口，就可以实现跨域通信。唯一需要注意的是，需要携带cookie信息时，需要将withCredentials设置为true即可。CORS的配置，完全在后端设置，配置起来也比较容易。<br>(简单请求)对于简单请求，浏览器会直接发送CORS请求，具体说来就是在header中加入origin请求头字段。同样，在响应头中，返回服务器设置的相关CORS头部字段，Access-Control-Allow-Origin字段为允许跨域请求的源。请求时浏览器在请求头的Origin中说明请求的源，服务器收到后发现允许该源跨域请求，则会成功返回<br>(复杂请求)以下是复杂请求的代码举例：</p><p>前端正常请求即可，以下原生请求方法或者$.ajax正常请求即可。<br>pageA(<a href="http://www.jack.com/index.html)代码如下：" target="_blank" rel="noopener">www.jack.com/index.html)代码如下：</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line">  if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123;</span><br><span class="line">    console.log(xhr.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(&quot;get&quot;,&quot;http://www.jesse.com/data.php&quot;);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure></p><p>服务端设置几条即可。<br>pageB(<a href="http://www.jesse.com/data.php)代码如下：" target="_blank" rel="noopener">www.jesse.com/data.php)代码如下：</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">  header(&quot;Access-Control-Allow-Origin: http://www.jack.com&quot;);//与简单的请求相同</span><br><span class="line">  header(&quot;Access-Control-Allow-Methods: GET, POST&quot;);//允许请求的方法</span><br><span class="line">  header(&quot;Access-Control-Max-Age: 3628800&quot;); //将这个请求缓存多长时间</span><br><span class="line">  $data = array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);//要返回的数据</span><br><span class="line">  echo json_encode($data);//输出</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>方法六：WebSocket</p><p>web socket是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web socket不适用)<br>web socket原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var socket = new WebSockt(&apos;ws://www.baidu.com&apos;);</span><br><span class="line">//http-&gt;ws; https-&gt;wss</span><br><span class="line">socket.send(&apos;hello WebSockt&apos;);</span><br><span class="line">socket.onmessage = function(event)&#123;</span><br><span class="line"> var data = event.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当服务器向客户端发来消息时，WebSocket会触发message事件，把返回的数据保存在event.data中</p><p>参考资料：<br><a href="https://blog.csdn.net/qq_40856225/article/details/81586560" target="_blank" rel="noopener">js中跨域问题详解</a><br><a href="https://blog.csdn.net/qq_31617637/article/details/72955239" target="_blank" rel="noopener">跨域问题出现原因和解决方案</a><br><a href="https://www.jb51.net/article/106780.htm" target="_blank" rel="noopener">详解Javascript几种跨域方式总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;方法一：Jsonp 需要目标服务器配合一个callback函数&lt;/p&gt;
&lt;p&gt;它的基本思想是:网页通过添加一个script元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 &lt;/p&gt;
&lt;p&gt;1)首先，网页动
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>this用法大盘点</title>
    <link href="http://yoursite.com/2019/08/12/this/"/>
    <id>http://yoursite.com/2019/08/12/this/</id>
    <published>2019-08-12T12:07:38.000Z</published>
    <updated>2019-10-14T11:01:25.954Z</updated>
    
    <content type="html"><![CDATA[<p>一：关于普通函数调用的this问题</p><h4 id="函数执行上下文中的this"><a href="#函数执行上下文中的this" class="headerlink" title="函数执行上下文中的this"></a>函数执行上下文中的this</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>这段代码中this是指向全局的，那么有什么方法来改变函数执行上下文中的this呢?</p><p>1)通过函数的call方法设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let bar = &#123;</span><br><span class="line">  myName : &quot; 极客邦 &quot;,</span><br><span class="line">  test1 : 1</span><br><span class="line">&#125;</span><br><span class="line">function foo()&#123;</span><br><span class="line">  this.myName = &quot; 极客时间 &quot;</span><br><span class="line">&#125;</span><br><span class="line">foo.call(bar)//foo.call方法为了改变this的指向，让其指向bar。bar中myName的值更换为极客时间。</span><br><span class="line">console.log(bar)</span><br></pre></td></tr></table></figure></p><p>2)通过对象调用方法设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">  name : &quot; 极客时间 &quot;, </span><br><span class="line">  showThis: function()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()//相当与myObj.showThis.call(myObj)方法调用，这里的this指向myObj这个对象。</span><br><span class="line"></span><br><span class="line">var obj = myObj.showThis</span><br><span class="line">obj()//这样调用的话myObj里的showThis中的this为window这个对象</span><br></pre></td></tr></table></figure></p><h4 id="下面介绍几种特殊的情况。"><a href="#下面介绍几种特殊的情况。" class="headerlink" title="下面介绍几种特殊的情况。"></a>下面介绍几种特殊的情况。</h4><p>1 解析：fn函数里的this还是obj对象，但调用f()函数时，里面的this变成全局的window了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    fn: function() &#123;</span><br><span class="line">        function f() &#123;</span><br><span class="line">            console.log(this);</span><br><span class="line">            console.log(this.x);</span><br><span class="line">        &#125;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.fn();</span><br></pre></td></tr></table></figure></p><p>2 解析:会先打印Aurelio De Rosa，之后打印John Doe。因为前一个相当于obj.prop来调用，后一个相当于全局window来调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var fullname = &apos;John Doe&apos;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    fullname: &apos;Colin Ihrig&apos;,</span><br><span class="line">    prop: &#123;</span><br><span class="line">        fullname: &apos;Aurelio De Rosa&apos;,</span><br><span class="line">        getFullname: function() &#123;</span><br><span class="line">            return this.fullname;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.prop.getFullname())</span><br><span class="line">var test = obj.prop.getFullname;</span><br><span class="line">console.log(test());</span><br></pre></td></tr></table></figure></p><p>3）通过构造函数中设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function CreateObj()&#123;</span><br><span class="line">  this.name = &quot; 极客时间 &quot;</span><br><span class="line">&#125;</span><br><span class="line">var myObj = new CreateObj()</span><br></pre></td></tr></table></figure></p><p>这里的this相当于CreateObj这个函数</p><p>二：关于立即执行函数和箭头函数以及setTimeout的this问题<br>1 解析:会先打印bar,bar 之后undefined和bar。立即执行函数里的this为window,所以为undefined。但是self还是为myObject这个对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    foo: &quot;bar&quot;,</span><br><span class="line">    func:function()&#123;</span><br><span class="line">        var self = this;</span><br><span class="line">        console.log(this.foo);</span><br><span class="line">        console.log(self.foo);</span><br><span class="line">        (function()&#123;</span><br><span class="line">            console.log(this.foo);</span><br><span class="line">            console.log(self.foo);</span><br><span class="line">        &#125;())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObject.func();</span><br></pre></td></tr></table></figure></p><p>2 这里我们看一下另一种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &apos;menglinghua&apos;,</span><br><span class="line">  say: function ()&#123;</span><br><span class="line">    return function ()&#123;</span><br><span class="line">      console.log(this)//这里的this指向window</span><br><span class="line">      console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.say()(); // undefined</span><br><span class="line">const person = &#123;</span><br><span class="line">  name: &apos;menglinghua&apos;,</span><br><span class="line">  say: function ()&#123;</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.say()(); // menglinghua</span><br></pre></td></tr></table></figure></p><p>3 解析：分别打印（1）{x: 10, test: ƒ, test1: ƒ, test2: ƒ, test3: ƒ} 10<br>（2）Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …} 1<br>（3）{x: 10, test: ƒ, test1: ƒ, test2: ƒ, test3: ƒ} 10<br>（4）Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …} 1<br>   总结：箭头函数找父级作用域即可，es6的箭头函数并不会创建其自身的执行上下文,所以箭头函数中的this取决于它的外部函数。setTimeout普通写法可以认为window调用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var x = 1</span><br><span class="line">var o = &#123;</span><br><span class="line">    x:10,</span><br><span class="line">    test:function()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">        console.log(this.x)</span><br><span class="line">    &#125;,</span><br><span class="line">    test1:()=&gt;&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">        console.log(this.x)</span><br><span class="line">    &#125;,</span><br><span class="line">    test2:function()&#123;</span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">            console.log(this)</span><br><span class="line">            console.log(this.x)</span><br><span class="line">        &#125;,100)</span><br><span class="line">    &#125;,</span><br><span class="line">    test3:function()&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(this)</span><br><span class="line">            console.log(this.x)</span><br><span class="line">        &#125;,100)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">o.test()</span><br><span class="line">o.test1()</span><br><span class="line">o.test2()</span><br><span class="line">o.test3()</span><br></pre></td></tr></table></figure></p><p>那么如何解决setTimeout的这种this指向的这种问题呢？看如下这一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name= 1;</span><br><span class="line">var MyObj = &#123;</span><br><span class="line">  name: 2,</span><br><span class="line">  showName: function()&#123;</span><br><span class="line">    console.log(this.name);//这里的this指向window的，会打印1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(MyObj.showName,1000)</span><br></pre></td></tr></table></figure></p><p>两种街解决方案：如下<br>1）箭头函数和function函数的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 箭头函数</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    MyObj.showName()</span><br><span class="line">&#125;, 1000);</span><br><span class="line">// 或者 function 函数</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  MyObj.showName();</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure></p><p>2）绑定bind函数，改变内部的this指向，返回一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(MyObj.showName.bind(MyObj), 1000)</span><br></pre></td></tr></table></figure></p><p>三：关于构造函数new的this问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var num1=10,num2=20;</span><br><span class="line">function add()&#123;</span><br><span class="line">    var num1 = 1,num2 = 2</span><br><span class="line">    console.log(this.num1 + this.num2)</span><br><span class="line">&#125;</span><br><span class="line">add()//30,this为window</span><br><span class="line">new add()//add()里this为add&#123;&#125;,只有this.num3=30,才会向里赋值。对于var num1 = 1,num2 = 2，不会对其造成影响，所以打印出来还是NaN</span><br><span class="line">var mm = add.bind(&#123;num1:200,num2:300&#125;)</span><br><span class="line">mm()//500,bind改变this的指向</span><br><span class="line">new mm()//还是add&#123;&#125;空对象，为NaN</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一：关于普通函数调用的this问题&lt;/p&gt;
&lt;h4 id=&quot;函数执行上下文中的this&quot;&gt;&lt;a href=&quot;#函数执行上下文中的this&quot; class=&quot;headerlink&quot; title=&quot;函数执行上下文中的this&quot;&gt;&lt;/a&gt;函数执行上下文中的this&lt;/h4&gt;&lt;fig
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react-key属性和virtual dom</title>
    <link href="http://yoursite.com/2019/08/06/react-key/"/>
    <id>http://yoursite.com/2019/08/06/react-key/</id>
    <published>2019-08-06T12:35:07.000Z</published>
    <updated>2019-08-06T15:13:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于virtual-dom实现视图更新中的时间复杂度的问题"><a href="#关于virtual-dom实现视图更新中的时间复杂度的问题" class="headerlink" title="关于virtual dom实现视图更新中的时间复杂度的问题"></a>关于virtual dom实现视图更新中的时间复杂度的问题</h4><p>React通过virtual dom来实现高效的视图更新。基本原理是用纯js对象模拟dom树，每当更新时，根据组件们的render方法计算出新的虚拟dom树，并与此前的虚拟dom树作diff，得到一个patch（差异补丁），最后映射到真实dom树上完成视图更新。而两棵树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，很少出现跨越层级移动DOM元素的情况，所以React采用了简化的diff算法，只会对virtual dom中同一个层级的元素进行对比，这样算法复杂度就可以达到 O(n)。</p><h4 id="样例分析"><a href="#样例分析" class="headerlink" title="样例分析"></a>样例分析</h4><p>由于React采用的diff算法是对新旧虚拟dom树同层级的元素挨个比较，碰到循环输出的元素时会有一些问题，比如列表。先来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 旧v-dom</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">// 新v-dom</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;zero&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>React在diff两棵树时，发现原来的两个li元素都与新v-dom中对应位置上的两个li元素不同，就会对其修改，并向真实dom树中插入新的second节点。实际上，我们可能只是进行了在first之前插入新zero节点的操作，而现在进行了额外的修改操作。<br>React官方文档提示我们应该使用key属性来解决上述问题。key是一个字符串，用来唯一标识同父同层级的兄弟元素。当React作diff时，只要子元素有key属性，便会去原v-dom树中相应位置（当前横向比较的层级）寻找是否有同key元素，比较它们是否完全相同，若是则复用该元素，免去不必要的操作。<br>延续第一个例子，如果每个li元素都有key属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 旧v-dom</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li key=&quot;1&quot;&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li key=&quot;2&quot;&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">// 新v-dom</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li key=&quot;0&quot;&gt;zero&lt;/li&gt;</span><br><span class="line">  &lt;li key=&quot;1&quot;&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li key=&quot;2&quot;&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><h4 id="日常开发中"><a href="#日常开发中" class="headerlink" title="日常开发中"></a>日常开发中</h4><p>代码举例,key属性常与map结合在一起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    constPhone &amp;&amp; constPhone.completed &amp;&amp; constPhone.data ?</span><br><span class="line">    constPhone.data.map((item, index) =&gt; &lt;option key=&#123;index&#125; value=&#123;item.country_code&#125;&gt;</span><br><span class="line">    +&#123;item.country_code&#125;</span><br><span class="line">    &lt;/option&gt;) : null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考资料：<a href="https://www.jianshu.com/p/0218ff2591ec" target="_blank" rel="noopener">React中key的必要性与使用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;关于virtual-dom实现视图更新中的时间复杂度的问题&quot;&gt;&lt;a href=&quot;#关于virtual-dom实现视图更新中的时间复杂度的问题&quot; class=&quot;headerlink&quot; title=&quot;关于virtual dom实现视图更新中的时间复杂度的问题&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>typescript的装饰器用法</title>
    <link href="http://yoursite.com/2019/08/05/ts-decorator/"/>
    <id>http://yoursite.com/2019/08/05/ts-decorator/</id>
    <published>2019-08-05T02:32:11.000Z</published>
    <updated>2019-08-05T04:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="核心理念："><a href="#核心理念：" class="headerlink" title="核心理念："></a>核心理念：</h4><p>装饰器:参数上，可以修改类的装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或行为。</p><p>通俗的讲装饰器就是一个方法，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能。</p><p>常见的装饰器有：类装饰器、属性装饰器、方法装饰器、参数装饰器</p><p>装饰器的写法：普通装饰器（无法传参） 、 装饰器工厂（可传参）</p><p>装饰器是过去几年中js最大的成就之一，已是Es7的标准特性之一</p><h4 id="1、类装饰器：类装饰器在类声明之前被声明（紧靠着类声明）。-类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。-传入一个参数"><a href="#1、类装饰器：类装饰器在类声明之前被声明（紧靠着类声明）。-类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。-传入一个参数" class="headerlink" title="1、类装饰器：类装饰器在类声明之前被声明（紧靠着类声明）。 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。 传入一个参数"></a>1、类装饰器：类装饰器在类声明之前被声明（紧靠着类声明）。 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。 传入一个参数</h4><p>1)类装饰器:普通装饰器（无法传参）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function logClass(params:any)&#123;</span><br><span class="line">    console.log(params);</span><br><span class="line">    // params 就是当前HttpClient类</span><br><span class="line">    params.prototype.apiUrl=&apos;动态扩展的属性&apos;;</span><br><span class="line">    params.prototype.run=function()&#123;</span><br><span class="line">        console.log(&apos;我是一个run方法&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@logClass</span><br><span class="line">class HttpClient&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    getData()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var http:any=new HttpClient();</span><br><span class="line">console.log(http.apiUrl);</span><br><span class="line">http.run();</span><br></pre></td></tr></table></figure></p><p>2)类装饰器:装饰器工厂（可传参）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function logClass(params:string)&#123;</span><br><span class="line">    return function(target:any)&#123;</span><br><span class="line">        //当前target的变量为传入的HttpClient类</span><br><span class="line">        console.log(target);</span><br><span class="line">        //当前params的变量为传入的http://www.itying.com/api值</span><br><span class="line">        console.log(params);</span><br><span class="line">        target.prototype.apiUrl=params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@logClass(&apos;http://www.itying.com/api&apos;)</span><br><span class="line">class HttpClient&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    getData()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var http:any=new HttpClient();</span><br><span class="line">//当前打印的变量值为http://www.itying.com/api值</span><br><span class="line">console.log(http.apiUrl);</span><br></pre></td></tr></table></figure></p><p>3）类装饰器 (重载构造函数)<br>说明:类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function logClass(target:any)&#123;</span><br><span class="line">    console.log(target);</span><br><span class="line">    //当前target的值为传入的HttpClient类,下面的定义了一个类来继承它。</span><br><span class="line">    return class extends target&#123;</span><br><span class="line">        apiUrl:any=&apos;我是修改后的数据&apos;;</span><br><span class="line">        getData()&#123;</span><br><span class="line">            this.apiUrl=this.apiUrl+&apos;----&apos;;</span><br><span class="line">            console.log(this.apiUrl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@logClass</span><br><span class="line">class HttpClient&#123;</span><br><span class="line">    public apiUrl:string | undefined;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.apiUrl=&apos;我是构造函数里面的apiUrl&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    getData()&#123;</span><br><span class="line">        console.log(this.apiUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var http=new HttpClient();</span><br><span class="line">http.getData();</span><br></pre></td></tr></table></figure></p><h4 id="2、属性装饰器"><a href="#2、属性装饰器" class="headerlink" title="2、属性装饰器"></a>2、属性装饰器</h4><p>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：<br>1）对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。<br>2）成员的名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function logProperty(params:any)&#123;</span><br><span class="line">    //params的值为传入的http://itying.com值。</span><br><span class="line">    return function(target:any,attr:any)&#123;</span><br><span class="line">        //target的值为HttpClient类，attr值为url值。</span><br><span class="line">        console.log(target);</span><br><span class="line">        console.log(attr);</span><br><span class="line">        target[attr]=params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HttpClient&#123;</span><br><span class="line">    @logProperty(&apos;http://itying.com&apos;)</span><br><span class="line">    public url:any |undefined;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    getData()&#123;</span><br><span class="line">        console.log(this.url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var http=new HttpClient();</span><br><span class="line">http.getData();</span><br></pre></td></tr></table></figure></p><h4 id="3、方法装饰器"><a href="#3、方法装饰器" class="headerlink" title="3、方法装饰器"></a>3、方法装饰器</h4><p>它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。<br>方法装饰会在运行时传入下列3个参数：<br>1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。<br>2、成员的名字。<br>3、成员的属性描述符。</p><p>1）方法装饰器一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function get(params:any)&#123;</span><br><span class="line">    return function(target:any,methodName:any,desc:any)&#123;</span><br><span class="line">        //target为HttpClient类</span><br><span class="line">        console.log(target);</span><br><span class="line">        //methodName方法为getData方法名字</span><br><span class="line">        console.log(methodName);</span><br><span class="line">        console.log(desc);</span><br><span class="line">        target.apiUrl=&apos;xxxx&apos;;</span><br><span class="line">        target.run=function()&#123;</span><br><span class="line">            console.log(&apos;run&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HttpClient&#123;  </span><br><span class="line">    public url:any |undefined;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @get(&apos;http://www.itying,com&apos;)</span><br><span class="line">    getData()&#123;</span><br><span class="line">        console.log(this.url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var http:any=new HttpClient();</span><br><span class="line">console.log(http.apiUrl);</span><br><span class="line">http.run();</span><br></pre></td></tr></table></figure></p><p>2）方法装饰器二<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function get(params:any)&#123;</span><br><span class="line">    return function(target:any,methodName:any,desc:any)&#123;</span><br><span class="line">        console.log(target);</span><br><span class="line">        console.log(methodName);</span><br><span class="line">        //desc.value方法为当前类里的getData方法。</span><br><span class="line">        console.log(desc.value);       </span><br><span class="line">        </span><br><span class="line">        //修改装饰器的方法  把装饰器方法里面传入的所有参数改为string类型</span><br><span class="line"></span><br><span class="line">        //1、保存当前的方法</span><br><span class="line"></span><br><span class="line">        var oMethod=desc.value;</span><br><span class="line">        desc.value=function(...args:any[])&#123;                </span><br><span class="line">            args=args.map((value)=&gt;&#123;</span><br><span class="line">                return String(value);</span><br><span class="line">            &#125;)</span><br><span class="line">            //没有下一句的话会把类中的getData方法给替代了，加上下一句类中的方法也会打印出来</span><br><span class="line">            oMethod.apply(this,args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HttpClient&#123;  </span><br><span class="line">    public url:any |undefined;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @get(&apos;http://www.itying,com&apos;)</span><br><span class="line">    getData(...args:any[])&#123;</span><br><span class="line">        console.log(args);</span><br><span class="line">        console.log(&apos;我是getData里面的方法&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var http=new HttpClient();</span><br><span class="line">http.getData(123,&apos;xxx&apos;);</span><br></pre></td></tr></table></figure></p><h4 id="4、方法参数装饰器"><a href="#4、方法参数装饰器" class="headerlink" title="4、方法参数装饰器"></a>4、方法参数装饰器</h4><p>参数装饰器表达式会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元素数据 ，传入下列3个参数：<br>1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。<br>2、方法的名字。<br>3、参数在函数参数列表中的索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function logParams(params:any)&#123;</span><br><span class="line"></span><br><span class="line">    return function(target:any,methodName:any,paramsIndex:any)&#123;</span><br><span class="line">        //params为xxxxx值</span><br><span class="line">        console.log(params);</span><br><span class="line">        //target为HttpClient类</span><br><span class="line">        console.log(target);</span><br><span class="line">        //methodName为getData名字</span><br><span class="line">        console.log(methodName);</span><br><span class="line">        //paramsIndex为0</span><br><span class="line">        console.log(paramsIndex);</span><br><span class="line">        </span><br><span class="line">        target.apiUrl=params;</span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class HttpClient&#123;  </span><br><span class="line">    public url:any |undefined;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">    &#125;           </span><br><span class="line">    getData(@logParams(&apos;xxxxx&apos;) uuid:any)&#123;       </span><br><span class="line">        //uuid值为123456</span><br><span class="line">        console.log(uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var http:any = new HttpClient();</span><br><span class="line">http.getData(123456);</span><br><span class="line">console.log( http.apiUrl);</span><br></pre></td></tr></table></figure></p><h4 id="总结执行顺序"><a href="#总结执行顺序" class="headerlink" title="总结执行顺序"></a>总结执行顺序</h4><p>装饰器执行顺序</p><p>属性》方法》方法参数》类</p><p>如果有多个同样的装饰器，它会先执行后面的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">function logClass1(params:string)&#123;</span><br><span class="line">    return function(target:any)&#123;</span><br><span class="line">      console.log(&apos;类装饰器1&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function logClass2(params:string)&#123;</span><br><span class="line">    return function(target:any)&#123;</span><br><span class="line">      console.log(&apos;类装饰器2&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function logAttribute1(params?:string)&#123;</span><br><span class="line">    return function(target:any,attrName:any)&#123;</span><br><span class="line">      console.log(&apos;属性装饰器1&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function logAttribute2(params?:string)&#123;</span><br><span class="line">    return function(target:any,attrName:any)&#123;</span><br><span class="line">      console.log(&apos;属性装饰器2&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function logMethod1(params?:string)&#123;</span><br><span class="line">    return function(target:any,attrName:any,desc:any)&#123;</span><br><span class="line">      console.log(&apos;方法装饰器1&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function logMethod2(params?:string)&#123;</span><br><span class="line">    return function(target:any,attrName:any,desc:any)&#123;</span><br><span class="line">      console.log(&apos;方法装饰器2&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function logParams1(params?:string)&#123;</span><br><span class="line">    return function(target:any,attrName:any,desc:any)&#123;</span><br><span class="line">      console.log(&apos;方法参数装饰器1&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function logParams2(params?:string)&#123;</span><br><span class="line">    return function(target:any,attrName:any,desc:any)&#123;</span><br><span class="line">      console.log(&apos;方法参数装饰器2&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@logClass1(&apos;http://www.itying.com/api&apos;)</span><br><span class="line">@logClass2(&apos;xxxx&apos;)</span><br><span class="line">class HttpClient&#123;</span><br><span class="line">    @logAttribute1()</span><br><span class="line">    @logAttribute2()</span><br><span class="line">    public apiUrl:string | undefined;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @logMethod1()</span><br><span class="line">    @logMethod2()</span><br><span class="line">    getData()&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setData(@logParams1() attr1:any,@logParams2() attr2:any,)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var http:any=new HttpClient();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;核心理念：&quot;&gt;&lt;a href=&quot;#核心理念：&quot; class=&quot;headerlink&quot; title=&quot;核心理念：&quot;&gt;&lt;/a&gt;核心理念：&lt;/h4&gt;&lt;p&gt;装饰器:参数上，可以修改类的装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或行为。&lt;/p&gt;
&lt;p&gt;通俗
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>typescript操作数据库的样例</title>
    <link href="http://yoursite.com/2019/08/04/ts-database/"/>
    <id>http://yoursite.com/2019/08/04/ts-database/</id>
    <published>2019-08-04T10:01:08.000Z</published>
    <updated>2019-08-05T05:01:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简单对TS的接口和泛型做一个小demo的举例"><a href="#简单对TS的接口和泛型做一个小demo的举例" class="headerlink" title="简单对TS的接口和泛型做一个小demo的举例"></a>简单对TS的接口和泛型做一个小demo的举例</h4><p>1)功能：定义一个操作数据库的库  支持 Mysql Mssql  MongoDb<br>2)要求1：Mysql MsSql  MongoDb功能一样  都有 add  update  delete  get方法<br>3)注意：约束统一的规范、以及代码重用<br>4)解决方案：需要约束规范所以要定义接口 ，需要代码重用所以用到泛型<br>1、接口：在面向对象的编程中，接口是一种规范的定义，它定义了行为和动作的规范<br>2、泛型 通俗理解：泛型就是解决 类 接口 方法的复用性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">interface DBI&lt;T&gt;&#123;</span><br><span class="line">    add(info:T):boolean;</span><br><span class="line">    update(info:T,id:number):boolean;</span><br><span class="line">    delete(id:number):boolean;</span><br><span class="line">    get(id:number):any[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个操作mysql数据库的类       注意：要实现泛型接口 这个类也应该是一个泛型类</span><br><span class="line"></span><br><span class="line">class MysqlDb&lt;T&gt; implements DBI&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">        console.log(&apos;数据库建立连接&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    add(info: T): boolean &#123;</span><br><span class="line"></span><br><span class="line">        console.log(info);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">       </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    update(info: T, id: number): boolean &#123;</span><br><span class="line">        throw new Error(&quot;Method not implemented.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    delete(id: number): boolean &#123;</span><br><span class="line">        throw new Error(&quot;Method not implemented.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    get(id: number): any[] &#123;</span><br><span class="line">        var list=[</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                title:&apos;xxxx&apos;,</span><br><span class="line">                desc:&apos;xxxxxxxxxx&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                title:&apos;xxxx&apos;,</span><br><span class="line">                desc:&apos;xxxxxxxxxx&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个操作mssql数据库的类  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MsSqlDb&lt;T&gt; implements DBI&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">        console.log(&apos;数据库建立连接&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    add(info: T): boolean &#123;</span><br><span class="line">        console.log(info);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;    </span><br><span class="line">    update(info: T, id: number): boolean &#123;</span><br><span class="line">        throw new Error(&quot;Method not implemented.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    delete(id: number): boolean &#123;</span><br><span class="line">        throw new Error(&quot;Method not implemented.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    get(id: number): any[] &#123;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        var list=[</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                title:&apos;xxxx&apos;,</span><br><span class="line">                desc:&apos;xxxxxxxxxx&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                title:&apos;xxxx&apos;,</span><br><span class="line">                desc:&apos;xxxxxxxxxx&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//操作用户表   定义一个User类和数据表做映射</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">class User&#123;</span><br><span class="line">    username:string | undefined;</span><br><span class="line">    password:string | undefined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var u=new User();</span><br><span class="line">u.username=&apos;张三111&apos;;</span><br><span class="line">u.password=&apos;123456&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var oMysql=new MysqlDb&lt;User&gt;(); //类作为参数来约束数据传入的类型 </span><br><span class="line">oMysql.add(u);</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class User&#123;</span><br><span class="line">    username:string | undefined;</span><br><span class="line">    password:string | undefined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var u=new User();</span><br><span class="line">u.username=&apos;张三2222&apos;;</span><br><span class="line">u.password=&apos;123456&apos;;</span><br><span class="line"></span><br><span class="line">var oMssql=new MsSqlDb&lt;User&gt;();</span><br><span class="line">oMssql.add(u);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获取User表 ID=4的数据</span><br><span class="line">var data=oMssql.get(4);</span><br><span class="line">console.log(data);</span><br></pre></td></tr></table></figure></p><h4 id="也可对上述代码实现模块化封装"><a href="#也可对上述代码实现模块化封装" class="headerlink" title="也可对上述代码实现模块化封装"></a>也可对上述代码实现模块化封装</h4><p>通过export将俩个泛型类暴露出去</p><p>1）module目录下db.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface DBI&lt;T&gt;&#123;</span><br><span class="line">    add(info:T):boolean;</span><br><span class="line">    update(info:T,id:number):boolean;</span><br><span class="line">    delete(id:number):boolean;</span><br><span class="line">    get(id:number):any[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个操作mysql数据库的类       注意：要实现泛型接口 这个类也应该是一个泛型类</span><br><span class="line"></span><br><span class="line">export class MysqlDb&lt;T&gt; implements DBI&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">        console.log(&apos;数据库建立连接&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    add(info: T): boolean &#123;</span><br><span class="line"></span><br><span class="line">        console.log(info);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">       </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    update(info: T, id: number): boolean &#123;</span><br><span class="line">        throw new Error(&quot;Method not implemented.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    delete(id: number): boolean &#123;</span><br><span class="line">        throw new Error(&quot;Method not implemented.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    get(id: number): any[] &#123;</span><br><span class="line">        var list=[</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                title:&apos;xxxx&apos;,</span><br><span class="line">                desc:&apos;xxxxxxxxxx&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                title:&apos;xxxx&apos;,</span><br><span class="line">                desc:&apos;xxxxxxxxxx&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个操作mssql数据库的类  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export class MsSqlDb&lt;T&gt; implements DBI&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">        console.log(&apos;数据库建立连接&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    add(info: T): boolean &#123;</span><br><span class="line">        console.log(info);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;    </span><br><span class="line">    update(info: T, id: number): boolean &#123;</span><br><span class="line">        throw new Error(&quot;Method not implemented.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    delete(id: number): boolean &#123;</span><br><span class="line">        throw new Error(&quot;Method not implemented.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    get(id: number): any[] &#123;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        var list=[</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                title:&apos;xxxx&apos;,</span><br><span class="line">                desc:&apos;xxxxxxxxxx&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                title:&apos;xxxx&apos;,</span><br><span class="line">                desc:&apos;xxxxxxxxxx&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2）model目录下的俩个文件</p><p>通过import来引入暴露的俩个泛型类</p><p>1：article.js文件下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123;MsSqlDb&#125; from &apos;../modules/db&apos;;</span><br><span class="line"></span><br><span class="line">//定义数据库的映射</span><br><span class="line">class ArticleClass&#123;</span><br><span class="line">    title:string | undefined;</span><br><span class="line">    desc:string | undefined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var ArticleModel=new MsSqlDb&lt;ArticleClass&gt;();</span><br><span class="line">export &#123;</span><br><span class="line">    ArticleClass,ArticleModel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2:user.ts文件下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123;MySqlDb&#125; from &apos;../modules/db&apos;;</span><br><span class="line"></span><br><span class="line">//定义数据库的映射</span><br><span class="line">class UserClass&#123;</span><br><span class="line">    username:string | undefined;</span><br><span class="line">    password:string | undefined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var UserModel=new MySqlDb&lt;UserClass&gt;();</span><br><span class="line">export &#123;</span><br><span class="line">    UserClass,UserModel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3）外面的index.ts文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123;UserClass,UserModel&#125; from &apos;./model/user&apos;;</span><br><span class="line"></span><br><span class="line">import &#123;ArticleClass,ArticleModel&#125; from &apos;./model/article&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//增加数据</span><br><span class="line">var u=new UserClass();</span><br><span class="line">u.username=&apos;张三&apos;;</span><br><span class="line">u.password=&apos;12345655654757&apos;;</span><br><span class="line">UserModel.add(u);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获取user表数据</span><br><span class="line">var res=UserModel.get(123);</span><br><span class="line">console.log(res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获取文章表的数据</span><br><span class="line">var aRes=ArticleModel.get(1);</span><br><span class="line">console.log(aRes);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简单对TS的接口和泛型做一个小demo的举例&quot;&gt;&lt;a href=&quot;#简单对TS的接口和泛型做一个小demo的举例&quot; class=&quot;headerlink&quot; title=&quot;简单对TS的接口和泛型做一个小demo的举例&quot;&gt;&lt;/a&gt;简单对TS的接口和泛型做一个小demo的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react-ref的属性使用盘点</title>
    <link href="http://yoursite.com/2019/07/28/react-ref/"/>
    <id>http://yoursite.com/2019/07/28/react-ref/</id>
    <published>2019-07-28T05:34:26.000Z</published>
    <updated>2019-07-28T06:34:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ref的简述"><a href="#1-ref的简述" class="headerlink" title="1:ref的简述"></a>1:ref的简述</h2><p>官方文档：在从 render 方法中返回 UI 结构之后，你可能想冲出 React 虚拟 DOM 的限制，在 render 返回的组件实例上调用某些方法。通常来说，这样做对于应用中的数据流动是不必要的，因为活跃的数据（ Reactive data ）流总是确保最新的 props 被传递到每一个从 render() 输出的子级中去。然而，仍然有几个场景使用这种方式是必须的，或者说是有益的：查找渲染出的组件的DOM标记（可以认为是DOM的标识ID），在一个大型的非React应用中使用React组件或者是将你现有的代码转化成React。</p><p>总结下来：ref属性其实就是为了获取DOM节点</p><h2 id="2-实战用法"><a href="#2-实战用法" class="headerlink" title="2:实战用法"></a>2:实战用法</h2><h3 id="一：给html的标签添加："><a href="#一：给html的标签添加：" class="headerlink" title="一：给html的标签添加："></a>一：给html的标签添加：</h3><p>question:什么时候回调函数会被被调用呢？<br>答：当组件挂载后和卸载后，以及ref属性本身发生变化时，回调函数就会被调用。</p><p>先举一个通俗易懂的小例子：我们已经把input元素存储在了this.textInput中，在focus函数中直接使用原生DOM API实现focus聚焦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Input extends Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    focus = () =&gt; &#123;</span><br><span class="line">        this.textInput.focus();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input ref=&#123;(input) =&gt; &#123; this.textInput = input &#125;&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="实际开发中"><a href="#实际开发中" class="headerlink" title="实际开发中:"></a>实际开发中:</h4><p>1)用在input标签上的用法，这里的c值是当前的dom节点，field值是传入的phone值或者smsCode值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">forceUpdater = field =&gt; (c) =&gt; &#123;</span><br><span class="line">    if (c) &#123;</span><br><span class="line">      c.value = this.state[field]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;input type=&apos;text&apos; placeholder=&apos;请输入手机号&apos; ref=&#123;this.forceUpdater(&apos;phone&apos;)&#125; default=&#123;phone&#125; data-field=&apos;phone&apos; onBlur=&#123;this.handleInputChange&#125; /&gt;</span><br><span class="line">&lt;input type=&apos;text&apos; placeholder=&apos;短信验证码&apos; ref=&#123;this.forceUpdater(&apos;smsCode&apos;)&#125; default=&#123;smsCode&#125; data-field=&apos;smsCode&apos; onBlur=&#123;this.handleInputChange&#125; /&gt;</span><br></pre></td></tr></table></figure></p><p>2)用在某一个标签上，获取整个dom节点。<br>这里的this.node为整个dom节点，el为dom节点的最后一个子元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    this.setPosition();</span><br><span class="line">&#125;</span><br><span class="line">setPosition() &#123;</span><br><span class="line">    const el = this.node.lastChild;</span><br><span class="line">    if (!el) return;</span><br><span class="line"></span><br><span class="line">    const left = (window.innerWidth - el.offsetWidth) / 2;</span><br><span class="line">    const top = (window.innerHeight - el.offsetHeight) / 2;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123; top, left &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;div className=&#123;cls&#125; ref=&#123;node =&gt; (this.node = node)&#125;&gt;</span><br><span class="line">      &#123;props.modal ? &lt;div className=&quot;smartui_mask&quot; style=&#123;props.maskStyle &amp;&amp; &#123;backgroundColor: &apos;black&apos;&#125;&#125; onClick=&#123;props.modalClose ? this.close : &apos;&apos;&#125; /&gt; : null&#125;</span><br><span class="line">      &lt;div className=&quot;smartui-layer-content&quot; style=&#123;styleObj&#125;&gt;</span><br><span class="line">        &lt;div className=&quot;smartui-layer-header&quot;&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className=&quot;smartui-layer-body&quot;&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="二：给组件添加。"><a href="#二：给组件添加。" class="headerlink" title="二：给组件添加。"></a>二：给组件添加。</h3><p>这里的startCounter方法是在Counter组件中定义的方法。注意：<counter>组件必须是使用class声明的组件，不然无法使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (res.code === 0) &#123;</span><br><span class="line">    this.changeErrorMsg(&apos;验证码已发往你的手机，请注意查收&apos;)</span><br><span class="line">    if (this.counter) &#123;</span><br><span class="line">        this.counter.startCounter()</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.changeErrorMsg(res.msg !== &apos;未知错误&apos; ? res.msg : &apos;网络繁忙，请稍后重试&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123; status === 2 &amp;&amp; &lt;div className=&apos;row row-smscode&apos;&gt;</span><br><span class="line">    &lt;input type=&apos;text&apos; placeholder=&apos;短信验证码&apos; ref=&#123;this.forceUpdater(&apos;smsCode&apos;)&#125; default=&#123;smsCode&#125; data-field=&apos;smsCode&apos; onBlur=&#123;this.handleInputChange&#125; /&gt;</span><br><span class="line">    &lt;Counter ref=&#123;(c) =&gt; &#123; if (c) &#123; this.counter = c &#125; &#125;&#125; onClick=&#123;this.checkSendSmsCode&#125; /&gt;</span><br><span class="line">&lt;/div&gt;&#125;</span><br></pre></td></tr></table></figure></counter></p><h3 id="三：不能在无状态组件中使用ref。"><a href="#三：不能在无状态组件中使用ref。" class="headerlink" title="三：不能在无状态组件中使用ref。"></a>三：不能在无状态组件中使用ref。</h3><p>原因很简单，因为ref引用的是组件的实例，而无状态组件准确的说是个函数组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function MyFunctionalComponent() &#123;</span><br><span class="line">    return &lt;input /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;MyFunctionalComponent</span><br><span class="line">                ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码是无法正常工作的。<br>参考资料：<a href="https://www.jianshu.com/p/6868174b0b34" target="_blank" rel="noopener">React ref属性使用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-ref的简述&quot;&gt;&lt;a href=&quot;#1-ref的简述&quot; class=&quot;headerlink&quot; title=&quot;1:ref的简述&quot;&gt;&lt;/a&gt;1:ref的简述&lt;/h2&gt;&lt;p&gt;官方文档：在从 render 方法中返回 UI 结构之后，你可能想冲出 React 虚拟 D
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react-loadable原理剖析和实战用法</title>
    <link href="http://yoursite.com/2019/07/21/react-loadable/"/>
    <id>http://yoursite.com/2019/07/21/react-loadable/</id>
    <published>2019-07-21T08:23:54.000Z</published>
    <updated>2019-07-21T10:45:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-为什么用到react-loadable？"><a href="#1-为什么用到react-loadable？" class="headerlink" title="1:为什么用到react-loadable？"></a>1:为什么用到react-loadable？</h3><p>在我们开发react页面时，我们会遇到一个问题，那就是打包后的js文件特别巨大，首屏加载会特别缓慢。这个时候我们应该讲代码进行分割，按需加载，将js 拆分成若干个chunk.js,用到就加载，react-loadable就可以很好地解决这个问题。</p><p>1）安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add react-loadable</span><br></pre></td></tr></table></figure></p><h3 id="2-实战用法-核心写法，中间会略去一部分"><a href="#2-实战用法-核心写法，中间会略去一部分" class="headerlink" title="2:实战用法(核心写法，中间会略去一部分)"></a>2:实战用法(核心写法，中间会略去一部分)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import &#123; Router, Route &#125; from &apos;react-router&apos;</span><br><span class="line">import Loadable from &apos;react-loadable&apos;</span><br><span class="line">// 大布局</span><br><span class="line">// 这个模块大部分页面会使用，不建议动态加载，否则会导致请求太多</span><br><span class="line">import Container from &apos;../containers&apos;</span><br><span class="line">const loadingStyle = &#123;</span><br><span class="line">  height: &apos;100%&apos;,</span><br><span class="line">  minHeight: 1000</span><br><span class="line">&#125;</span><br><span class="line">const Loading = () =&gt; &lt;div style=&#123;loadingStyle&#125; /&gt;</span><br><span class="line">//会员页</span><br><span class="line">const VipPage1 = Loadable(&#123;</span><br><span class="line">  loader: () =&gt; import(&apos;../../../desktop/pages/vip&apos;),</span><br><span class="line">  loading: Loading</span><br><span class="line">&#125;)</span><br><span class="line">const VipPage2 = Loadable(&#123;</span><br><span class="line">  loader: () =&gt; import(&apos;../../../mobile/pages/vip&apos;),</span><br><span class="line">  loading: Loading</span><br><span class="line">&#125;)</span><br><span class="line">export default function factory(isMobile = false) &#123;</span><br><span class="line">    const VipPage = !isMobile ? VipPage1 : VipPage2</span><br><span class="line">    return function(history) &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Route onEnter=&#123;enterRouteLog&#125; onChange=&#123;changeRouteLog&#125; component=&#123;Container&#125;&gt;</span><br><span class="line">                &lt;Route path=&apos;/vip/toefl&apos; component=&#123;VipPage&#125; module=&apos;home&apos; onEnter=&#123;enterLeafRouteLog&#125; onLeave=&#123;leaveRouteLog&#125; /&gt;</span><br><span class="line">            &lt;/Route&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以此识别页面的移动端还是PC端。react-loadable是以组件级别来分割代码的，这意味着，我们不仅可以根据路由按需加载，还可以根据组件按需加载，使用方式和路由分割一样，只用修改组件的引入方式即可<br>参考资料：<a href="https://www.jianshu.com/p/871de188adf6" target="_blank" rel="noopener">使用react-loadable实现代码分割</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-为什么用到react-loadable？&quot;&gt;&lt;a href=&quot;#1-为什么用到react-loadable？&quot; class=&quot;headerlink&quot; title=&quot;1:为什么用到react-loadable？&quot;&gt;&lt;/a&gt;1:为什么用到react-loadabl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nodejs-express-中间件关于参数处理</title>
    <link href="http://yoursite.com/2019/05/27/express-%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/05/27/express-中间件/</id>
    <published>2019-05-27T03:57:03.000Z</published>
    <updated>2019-05-27T04:40:08.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于前端发送请求，后台根据请求方式不同，做出不同的处理的小demo。"><a href="#关于前端发送请求，后台根据请求方式不同，做出不同的处理的小demo。" class="headerlink" title="关于前端发送请求，后台根据请求方式不同，做出不同的处理的小demo。"></a>关于前端发送请求，后台根据请求方式不同，做出不同的处理的小demo。</h4><p>后台部分(根据前端发来的type类型不同来处理)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const app = express();</span><br><span class="line">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class="line">//挂载内置中间件</span><br><span class="line">app.use(express.static(&apos;public&apos;));</span><br><span class="line">//挂载参数处理中间件(post)</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended:false&#125;));</span><br><span class="line">//处理json格式的参数</span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line"></span><br><span class="line">//处理get提交参数</span><br><span class="line">app.get(&apos;/login&apos;,(req,res)=&gt;&#123;</span><br><span class="line">    let data = req.query;</span><br><span class="line">    console.log(data);</span><br><span class="line">    res.send(&apos;get data&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">//处理post提交参数</span><br><span class="line">app.post(&apos;/login&apos;,(req,res)=&gt;&#123;</span><br><span class="line">    let data = req.body;</span><br><span class="line">    if(data.username == &apos;admin&apos; $$ data.password == &apos;123&apos;)&#123;</span><br><span class="line">        res.send(&apos;success&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        res.send(&apos;failure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//处理put提交参数</span><br><span class="line">app.put(&apos;/login&apos;,(req,res)=&gt;&#123;</span><br><span class="line">    res.end(&apos;put data&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">//处理delete提交参数</span><br><span class="line">app.delete(&apos;/login&apos;,(req,res)=&gt;&#123;</span><br><span class="line">    res.end(&apos;delete data&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000,()=&#123;</span><br><span class="line">    console.log(&apos;running...&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>前端部分(在public文件夹下)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.4.1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        $(function()&#123;</span><br><span class="line">            $(&apos;btn&apos;).click(function()&#123;</span><br><span class="line">                var obj = &#123;</span><br><span class="line">                    username: $(&apos;#username&apos;).val(),</span><br><span class="line">                    password: $(&apos;#password&apos;).val()</span><br><span class="line">                &#125;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    type : &apos;post&apos;,</span><br><span class="line">                    url: &apos;http://localhost:3000/login&apos;,</span><br><span class="line">                    contentType: &apos;application/json&apos;,</span><br><span class="line">                    dataType:&apos;text&apos;,</span><br><span class="line">                    data:JSON.stringify(obj),</span><br><span class="line">                    success:function(data)&#123;</span><br><span class="line">                        console.log(data)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;http://localhost:3000/login&quot; method=&quot;get&quot;&gt;</span><br><span class="line">        用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt;&lt;br&gt;</span><br><span class="line">        密码： &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot;&gt;&lt;/br&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;关于前端发送请求，后台根据请求方式不同，做出不同的处理的小demo。&quot;&gt;&lt;a href=&quot;#关于前端发送请求，后台根据请求方式不同，做出不同的处理的小demo。&quot; class=&quot;headerlink&quot; title=&quot;关于前端发送请求，后台根据请求方式不同，做出不同
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="http://yoursite.com/2019/05/24/webpack/"/>
    <id>http://yoursite.com/2019/05/24/webpack/</id>
    <published>2019-05-24T14:59:43.000Z</published>
    <updated>2019-05-25T03:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是webpack"><a href="#1-什么是webpack" class="headerlink" title="1:什么是webpack?"></a>1:什么是webpack?</h3><p>它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</p><h3 id="2-为什么要用webpack"><a href="#2-为什么要用webpack" class="headerlink" title="2:为什么要用webpack?"></a>2:为什么要用webpack?</h3><p>1)模块化，让我们可以把复杂的程序细化为小的文件;<br>2)类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能能转换为JavaScript文件使浏览器可以识别；<br>3)scss，less等CSS预处理器<br>………<br>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。</p><h3 id="3-webpack相对于其他前端自动化构建工具的优势所在？"><a href="#3-webpack相对于其他前端自动化构建工具的优势所在？" class="headerlink" title="3:webpack相对于其他前端自动化构建工具的优势所在？"></a>3:webpack相对于其他前端自动化构建工具的优势所在？</h3><h4 id="优点：模块化"><a href="#优点：模块化" class="headerlink" title="优点：模块化"></a>优点：模块化</h4><p>在webpack看来一切都是模块！这就是它不可不说的优点，包括你的JavaScript代码，也包括CSS和fonts以及图片等等等，只有通过合适的loaders，它们都可以被当做模块被处理。</p><h3 id="4-1-webpack的安装"><a href="#4-1-webpack的安装" class="headerlink" title="4.1:webpack的安装"></a>4.1:webpack的安装</h3><p>在开始之前，请确保安装了 Node.js 的最新版本<br>1)要安装最新版本或特定版本，请运行以下命令之一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack</span><br><span class="line">npm install --save-dev webpack@&lt;version&gt;</span><br></pre></td></tr></table></figure></p><p>2)如果你使用 webpack 4+ 版本，你还需要安装 CLI。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-cli</span><br></pre></td></tr></table></figure></p><p>3)对于大多数项目，我们建议本地安装。这可以使我们在引入破坏式变更(breaking change)的依赖时，更容易分别升级项目。通常，webpack 通过运行一个或多个 npm scripts，会在本地 node_modules 目录中查找安装的 webpack：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack --config webpack.config.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4)总结来说3个基础安装步骤<br>mkdir webpack-demo &amp;&amp; cd webpack-demo<br>npm init -y<br>npm install webpack webpack-cli –save-dev</p><h3 id="4-2-webpack的简单入门"><a href="#4-2-webpack的简单入门" class="headerlink" title="4.2:webpack的简单入门"></a>4.2:webpack的简单入门</h3><p>配置文件webpack.config.js<br>1)入口entry和出口output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;my-first-webpack.bundle.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>2)loader加载器<br>原理:loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！</p><p>1:首先安装对应的loader<br>告诉webpack加载css文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br></pre></td></tr></table></figure></p><p>将 TypeScript 转为 JavaScript<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev ts-loader</span><br></pre></td></tr></table></figure></p><p>2:在webpack.config.js中进行配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; test: /\.css$/, use: &apos;css-loader&apos; &#125;,</span><br><span class="line">      &#123; test: /\.ts$/, use: &apos;ts-loader&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>3)插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //通过 npm 安装</span><br><span class="line">const webpack = require(&apos;webpack&apos;); //访问内置的插件</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">  entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;my-first-webpack.bundle.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(js|jsx)$/,</span><br><span class="line">        use: &apos;babel-loader&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure></p><h3 id="5-webpack支持的模块？"><a href="#5-webpack支持的模块？" class="headerlink" title="5:webpack支持的模块？"></a>5:webpack支持的模块？</h3><p>webpack 通过 loader 可以支持各种语言和预处理器编写模块。loader 描述了 webpack 如何处理 非 JavaScript(non-JavaScript) _模块_，并且在 bundle 中引入这些依赖。 webpack 社区已经为各种流行语言和语言处理器构建了 loader，包括：</p><p>1)CoffeeScript<br>2)TypeScript<br>3)ESNext (Babel)<br>4)Sass<br>5)Less<br>6)Stylus<br>总的来说，webpack 提供了可定制的、强大和丰富的 API，允许任何技术栈使用 webpack，保持了在你的开发、测试和生成流程中无侵入性(non-opinionated)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是webpack&quot;&gt;&lt;a href=&quot;#1-什么是webpack&quot; class=&quot;headerlink&quot; title=&quot;1:什么是webpack?&quot;&gt;&lt;/a&gt;1:什么是webpack?&lt;/h3&gt;&lt;p&gt;它做的事情是，分析你的项目结构，找到JavaScript
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>轻量级js框架--zepto.js</title>
    <link href="http://yoursite.com/2019/05/18/zepto/"/>
    <id>http://yoursite.com/2019/05/18/zepto/</id>
    <published>2019-05-18T07:34:00.000Z</published>
    <updated>2019-05-24T14:52:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>之所以说Zepto和JQuery超级像，是因为他们的用法一样，除了有那么一点不同之外，基本没有任何区别，如果你会用JQuery，那么，你就会用Zepto。<br>但是相比较之下，Zepto是比JQuery更加轻量级的一款JavaScript库，更加倾向于应用的开发。</p><p>zepto.js是简化的javascript库<br>zepto的API是参考jQuery的API</p><p>zepto中touch相关事件<br>touchstart<br>touchstart是手指刚触摸到元素时触发的事件<br>touchmove<br>touchmove是手指移动时触发的事件<br>touchend<br>当手指离开指定元素时触发</p><p>用法基本跟jQuery一致，直接上手使用即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之所以说Zepto和JQuery超级像，是因为他们的用法一样，除了有那么一点不同之外，基本没有任何区别，如果你会用JQuery，那么，你就会用Zepto。&lt;br&gt;但是相比较之下，Zepto是比JQuery更加轻量级的一款JavaScript库，更加倾向于应用的开发。&lt;/p&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
